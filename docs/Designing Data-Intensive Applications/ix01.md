---
sidebar_position: 22
---

# Index

### A

- aborts (transactions), [Transactions](ch07.md), [Atomicity](ch07.md)
  
  - in two-phase commit, [Introduction to two-phase commit](ch09.md)
  - performance of optimistic concurrency control, [Performance of serializable snapshot isolation](ch07.md)
  - retrying aborted transactions, [Handling errors and aborts](ch07.md)
- abstraction, [Simplicity: Managing Complexity](ch01.md), [Data Models and Query Languages](ch02.md), [Transactions](ch07.md), [Summary](ch07.md), [Consistency and Consensus](ch09.md)
- access path (in network model), [The network model](ch02.md), [The SPARQL query language](ch02.md)
- accidental complexity, removing, [Simplicity: Managing Complexity](ch01.md)
- accountability, [Responsibility and accountability](ch12.md)
- ACID properties (transactions), [Transaction Processing or Analytics?](ch03.md), [The Meaning of ACID](ch07.md)
  
  - atomicity, [Atomicity](ch07.md), [Single-Object and Multi-Object Operations](ch07.md)
  - consistency, [Consistency](ch07.md), [Maintaining integrity in the face of software bugs](ch12.md)
  - durability, [Durability](ch07.md)
  - isolation, [Isolation](ch07.md), [Single-Object and Multi-Object Operations](ch07.md)
- acknowledgements (messaging), [Acknowledgments and redelivery](ch11.md)
- active/active replication (see multi-leader replication)
- active/passive replication (see leader-based replication)
- ActiveMQ (messaging), [Message brokers](ch04.md), [Message brokers compared to databases](ch11.md)
  
  - distributed transaction support, [XA transactions](ch09.md)
- ActiveRecord (object-relational mapper), [The Object-Relational Mismatch](ch02.md), [Handling errors and aborts](ch07.md)
- actor model, [Distributed actor frameworks](ch04.md)
  
  - (see also message-passing)
  - comparison to Pregel model, [The Pregel processing model](ch10.md)
  - comparison to stream processing, [Message passing and RPC](ch11.md)
- Advanced Message Queuing Protocol (see AMQP)
- aerospace systems, [Reliability](ch01.md), [Human Errors](ch01.md), [Byzantine Faults](ch08.md), [Membership services](ch09.md)
- aggregation
  
  - data cubes and materialized views, [Aggregation: Data Cubes and Materialized Views](ch03.md)
  - in batch processes, [GROUP BY](ch10.md)
  - in stream processes, [Stream analytics](ch11.md)
- aggregation pipeline query language, [MapReduce Querying](ch02.md)
- Agile, [Evolvability: Making Change Easy](ch01.md)
  
  - minimizing irreversibility, [Philosophy of batch process outputs](ch10.md), [Reprocessing data for application evolution](ch12.md)
  - moving faster with confidence, [The end-to-end argument again](ch12.md)
  - Unix philosophy, [The Unix Philosophy](ch10.md)
- agreement, [Fault-Tolerant Consensus](ch09.md)
  
  - (see also consensus)
- Airflow (workflow scheduler), [MapReduce workflows](ch10.md)
- Ajax, [Dataflow Through Services: REST and RPC](ch04.md)
- Akka (actor framework), [Distributed actor frameworks](ch04.md)
- algorithms
  
  - algorithm correctness, [Correctness of an algorithm](ch08.md)
  - B-trees, [B-Trees](ch03.md)-[B-tree optimizations](ch03.md)
  - for distributed systems, [System Model and Reality](ch08.md)
  - hash indexes, [Hash Indexes](ch03.md)-[Hash Indexes](ch03.md)
  - mergesort, [SSTables and LSM-Trees](ch03.md), [Distributed execution of MapReduce](ch10.md), [Sort-merge joins](ch10.md)
  - red-black trees, [Constructing and maintaining SSTables](ch03.md)
  - SSTables and LSM-trees, [SSTables and LSM-Trees](ch03.md)-[Performance optimizations](ch03.md)
- all-to-all replication topologies, [Multi-Leader Replication Topologies](ch05.md)
- AllegroGraph (database), [Graph-Like Data Models](ch02.md)
- ALTER TABLE statement (SQL), [Schema flexibility in the document model](ch02.md), [Encoding and Evolution](ch04.md)
- Amazon
  
  - Dynamo (database), [Leaderless Replication](ch05.md)
- Amazon Web Services (AWS), [Hardware Faults](ch01.md)
  
  - Kinesis Streams (messaging), [Using logs for message storage](ch11.md)
  - network reliability, [Network Faults in Practice](ch08.md)
  - postmortems, [Software Errors](ch01.md)
  - RedShift (database), [The divergence between OLTP databases and data warehouses](ch03.md)
  - S3 (object storage), [MapReduce and Distributed Filesystems](ch10.md)
    
    - checking data integrity, [Don’t just blindly trust what they promise](ch12.md)
- amplification
  
  - of bias, [Bias and discrimination](ch12.md)
  - of failures, [Limitations of distributed transactions](ch09.md), [Maintaining derived state](ch12.md)
  - of tail latency, [Describing Performance](ch01.md), [Partitioning Secondary Indexes by Document](ch06.md)
  - write amplification, [Advantages of LSM-trees](ch03.md)
- AMQP (Advanced Message Queuing Protocol), [Message brokers compared to databases](ch11.md)
  
  - (see also messaging systems)
  - comparison to log-based messaging, [Logs compared to traditional messaging](ch11.md), [Replaying old messages](ch11.md)
  - message ordering, [Acknowledgments and redelivery](ch11.md)
- analytics, [Transaction Processing or Analytics?](ch03.md)
  
  - comparison to transaction processing, [Transaction Processing or Analytics?](ch03.md)
  - data warehousing (see data warehousing)
  - parallel query execution in MPP databases, [Comparing Hadoop to Distributed Databases](ch10.md)
  - predictive (see predictive analytics)
  - relation to batch processing, [The Output of Batch Workflows](ch10.md)
  - schemas for, [Stars and Snowflakes: Schemas for Analytics](ch03.md)-[Stars and Snowflakes: Schemas for Analytics](ch03.md)
  - snapshot isolation for queries, [Snapshot Isolation and Repeatable Read](ch07.md)
  - stream analytics, [Stream analytics](ch11.md)
  - using MapReduce, analysis of user activity events (example), [Example: analysis of user activity events](ch10.md)
- anti-caching (in-memory databases), [Keeping everything in memory](ch03.md)
- anti-entropy, [Read repair and anti-entropy](ch05.md)
- Apache ActiveMQ (see ActiveMQ)
- Apache Avro (see Avro)
- Apache Beam (see Beam)
- Apache BookKeeper (see BookKeeper)
- Apache Cassandra (see Cassandra)
- Apache CouchDB (see CouchDB)
- Apache Curator (see Curator)
- Apache Drill (see Drill)
- Apache Flink (see Flink)
- Apache Giraph (see Giraph)
- Apache Hadoop (see Hadoop)
- Apache HAWQ (see HAWQ)
- Apache HBase (see HBase)
- Apache Helix (see Helix)
- Apache Hive (see Hive)
- Apache Impala (see Impala)
- Apache Jena (see Jena)
- Apache Kafka (see Kafka)
- Apache Lucene (see Lucene)
- Apache MADlib (see MADlib)
- Apache Mahout (see Mahout)
- Apache Oozie (see Oozie)
- Apache Parquet (see Parquet)
- Apache Qpid (see Qpid)
- Apache Samza (see Samza)
- Apache Solr (see Solr)
- Apache Spark (see Spark)
- Apache Storm (see Storm)
- Apache Tajo (see Tajo)
- Apache Tez (see Tez)
- Apache Thrift (see Thrift)
- Apache ZooKeeper (see ZooKeeper)
- Apama (stream analytics), [Complex event processing](ch11.md)
- append-only B-trees, [B-tree optimizations](ch03.md), [Indexes and snapshot isolation](ch07.md)
- append-only files (see logs)
- Application Programming Interfaces (APIs), [Thinking About Data Systems](ch01.md), [Data Models and Query Languages](ch02.md)
  
  - for batch processing, [MapReduce workflows](ch10.md)
  - for change streams, [API support for change streams](ch11.md)
  - for distributed transactions, [XA transactions](ch09.md)
  - for graph processing, [The Pregel processing model](ch10.md)
  - for services, [Dataflow Through Services: REST and RPC](ch04.md)-[Data encoding and evolution for RPC](ch04.md)
    
    - (see also services)
    - evolvability, [Data encoding and evolution for RPC](ch04.md)
    - RESTful, [Web services](ch04.md)
    - SOAP, [Web services](ch04.md)
- application state (see state)
- approximate search (see similarity search)
- archival storage, data from databases, [Archival storage](ch04.md)
- arcs (see edges)
- arithmetic mean, [Describing Performance](ch01.md)
- ASCII text, [Thrift and Protocol Buffers](ch04.md), [A uniform interface](ch10.md)
- ASN.1 (schema language), [The Merits of Schemas](ch04.md)
- asynchronous networks, [Unreliable Networks](ch08.md), [Glossary](glossary01.md)
  
  - comparison to synchronous networks, [Synchronous Versus Asynchronous Networks](ch08.md)
  - formal model, [System Model and Reality](ch08.md)
- asynchronous replication, [Synchronous Versus Asynchronous Replication](ch05.md), [Glossary](glossary01.md)
  
  - conflict detection, [Synchronous versus asynchronous conflict detection](ch05.md)
  - data loss on failover, [Leader failure: Failover](ch05.md)
  - reads from asynchronous follower, [Problems with Replication Lag](ch05.md)
- Asynchronous Transfer Mode (ATM), [Can we not simply make network delays predictable?](ch08.md)
- atomic broadcast (see total order broadcast)
- atomic clocks (caesium clocks), [Clock readings have a confidence interval](ch08.md), [Synchronized clocks for global snapshots](ch08.md)
  
  - (see also clocks)
- atomicity (concurrency), [Glossary](glossary01.md)
  
  - atomic increment-and-get, [Implementing total order broadcast using linearizable storage](ch09.md)
  - compare-and-set, [Compare-and-set](ch07.md), [What Makes a System Linearizable?](ch09.md)
    
    - (see also compare-and-set operations)
  - replicated operations, [Conflict resolution and replication](ch07.md)
  - write operations, [Atomic write operations](ch07.md)
- atomicity (transactions), [Atomicity](ch07.md), [Single-Object and Multi-Object Operations](ch07.md), [Glossary](glossary01.md)
  
  - atomic commit, [Distributed Transactions and Consensus](ch09.md)
    
    - avoiding, [Multi-partition request processing](ch12.md), [Coordination-avoiding data systems](ch12.md)
    - blocking and nonblocking, [Three-phase commit](ch09.md)
    - in stream processing, [Exactly-once message processing](ch09.md), [Atomic commit revisited](ch11.md)
    - maintaining derived data, [Keeping Systems in Sync](ch11.md)
  - for multi-object transactions, [Single-Object and Multi-Object Operations](ch07.md)
  - for single-object writes, [Single-object writes](ch07.md)
- auditability, [Trust, but Verify](ch12.md)-[Tools for auditable data systems](ch12.md)
  
  - designing for, [Designing for auditability](ch12.md)
  - self-auditing systems, [A culture of verification](ch12.md)
  - through immutability, [Advantages of immutable events](ch11.md)
  - tools for auditable data systems, [Tools for auditable data systems](ch12.md)
- availability, [Hardware Faults](ch01.md)
  
  - (see also fault tolerance)
  - in CAP theorem, [The CAP theorem](ch09.md)
  - in service level agreements (SLAs), [Describing Performance](ch01.md)
- Avro (data format), [Avro](ch04.md)-[Code generation and dynamically typed languages](ch04.md)
  
  - code generation, [Code generation and dynamically typed languages](ch04.md)
  - dynamically generated schemas, [Dynamically generated schemas](ch04.md)
  - object container files, [But what is the writer’s schema?](ch04.md), [Archival storage](ch04.md), [Philosophy of batch process outputs](ch10.md)
  - reader determining writer’s schema, [But what is the writer’s schema?](ch04.md)
  - schema evolution, [The writer’s schema and the reader’s schema](ch04.md)
  - use in Hadoop, [Philosophy of batch process outputs](ch10.md)
- awk (Unix tool), [Simple Log Analysis](ch10.md)
- AWS (see Amazon Web Services)
- Azure (see Microsoft)

### B

- B-trees (indexes), [B-Trees](ch03.md)-[B-tree optimizations](ch03.md)
  
  - append-only/copy-on-write variants, [B-tree optimizations](ch03.md), [Indexes and snapshot isolation](ch07.md)
  - branching factor, [B-Trees](ch03.md)
  - comparison to LSM-trees, [Comparing B-Trees and LSM-Trees](ch03.md)-[Downsides of LSM-trees](ch03.md)
  - crash recovery, [Making B-trees reliable](ch03.md)
  - growing by splitting a page, [B-Trees](ch03.md)
  - optimizations, [B-tree optimizations](ch03.md)
  - similarity to dynamic partitioning, [Dynamic partitioning](ch06.md)
- backpressure, [Messaging Systems](ch11.md), [Glossary](glossary01.md)
  
  - in TCP, [Network congestion and queueing](ch08.md)
- backups
  
  - database snapshot for replication, [Setting Up New Followers](ch05.md)
  - integrity of, [Don’t just blindly trust what they promise](ch12.md)
  - snapshot isolation for, [Snapshot Isolation and Repeatable Read](ch07.md)
  - use for ETL processes, [Example: analysis of user activity events](ch10.md)
- backward compatibility, [Encoding and Evolution](ch04.md)
- BASE, contrast to ACID, [The Meaning of ACID](ch07.md)
- bash shell (Unix), [Data Structures That Power Your Database](ch03.md), [The Unix Philosophy](ch10.md), [What’s missing?](ch12.md)
- batch processing, [Relational Model Versus Document Model](ch02.md), [Batch Processing](ch10.md)-[Summary](ch10.md), [Glossary](glossary01.md)
  
  - combining with stream processing
    
    - lambda architecture, [The lambda architecture](ch12.md)
    - unifying technologies, [Unifying batch and stream processing](ch12.md)
  - comparison to MPP databases, [Comparing Hadoop to Distributed Databases](ch10.md)-[Designing for frequent faults](ch10.md)
  - comparison to stream processing, [Processing Streams](ch11.md)
  - comparison to Unix, [Philosophy of batch process outputs](ch10.md)-[Philosophy of batch process outputs](ch10.md)
  - dataflow engines, [Dataflow engines](ch10.md)-[Discussion of materialization](ch10.md)
  - fault tolerance, [Bringing related data together in the same place](ch10.md), [Philosophy of batch process outputs](ch10.md), [Fault tolerance](ch10.md), [Messaging Systems](ch11.md)
  - for data integration, [Batch and Stream Processing](ch12.md)-[Unifying batch and stream processing](ch12.md)
  - graphs and iterative processing, [Graphs and Iterative Processing](ch10.md)-[Parallel execution](ch10.md)
  - high-level APIs and languages, [MapReduce workflows](ch10.md), [High-Level APIs and Languages](ch10.md)-[Specialization for different domains](ch10.md)
  - log-based messaging and, [Replaying old messages](ch11.md)
  - maintaining derived state, [Maintaining derived state](ch12.md)
  - MapReduce and distributed filesystems, [MapReduce and Distributed Filesystems](ch10.md)-[Key-value stores as batch process output](ch10.md)
    
    - (see also MapReduce)
  - measuring performance, [Describing Performance](ch01.md), [Batch Processing](ch10.md)
  - outputs, [The Output of Batch Workflows](ch10.md)-[Key-value stores as batch process output](ch10.md)
    
    - key-value stores, [Key-value stores as batch process output](ch10.md)
    - search indexes, [Building search indexes](ch10.md)
  - using Unix tools (example), [Batch Processing with Unix Tools](ch10.md)-[Sorting versus in-memory aggregation](ch10.md)
- Bayou (database), [Uniqueness in log-based messaging](ch12.md)
- Beam (dataflow library), [Unifying batch and stream processing](ch12.md)
- bias, [Bias and discrimination](ch12.md)
- big ball of mud, [Simplicity: Managing Complexity](ch01.md)
- Bigtable data model, [Data locality for queries](ch02.md), [Column Compression](ch03.md)
- binary data encodings, [Binary encoding](ch04.md)-[The Merits of Schemas](ch04.md)
  
  - Avro, [Avro](ch04.md)-[Code generation and dynamically typed languages](ch04.md)
  - MessagePack, [Binary encoding](ch04.md)-[Binary encoding](ch04.md)
  - Thrift and Protocol Buffers, [Thrift and Protocol Buffers](ch04.md)-[Datatypes and schema evolution](ch04.md)
- binary encoding
  
  - based on schemas, [The Merits of Schemas](ch04.md)
  - by network drivers, [The Merits of Schemas](ch04.md)
- binary strings, lack of support in JSON and XML, [JSON, XML, and Binary Variants](ch04.md)
- BinaryProtocol encoding (Thrift), [Thrift and Protocol Buffers](ch04.md)
- Bitcask (storage engine), [Hash Indexes](ch03.md)
  
  - crash recovery, [Hash Indexes](ch03.md)
- Bitcoin (cryptocurrency), [Tools for auditable data systems](ch12.md)
  
  - Byzantine fault tolerance, [Byzantine Faults](ch08.md)
  - concurrency bugs in exchanges, [Weak Isolation Levels](ch07.md)
- bitmap indexes, [Column Compression](ch03.md)
- blockchains, [Tools for auditable data systems](ch12.md)
  
  - Byzantine fault tolerance, [Byzantine Faults](ch08.md)
- blocking atomic commit, [Three-phase commit](ch09.md)
- Bloom (programming language), [Designing Applications Around Dataflow](ch12.md)
- Bloom filter (algorithm), [Performance optimizations](ch03.md), [Stream analytics](ch11.md)
- BookKeeper (replicated log), [Allocating work to nodes](ch09.md)
- Bottled Water (change data capture), [Implementing change data capture](ch11.md)
- bounded datasets, [Summary](ch10.md), [Stream Processing](ch11.md), [Glossary](glossary01.md)
  
  - (see also batch processing)
- bounded delays, [Glossary](glossary01.md)
  
  - in networks, [Synchronous Versus Asynchronous Networks](ch08.md)
  - process pauses, [Response time guarantees](ch08.md)
- broadcast hash joins, [Broadcast hash joins](ch10.md)
- brokerless messaging, [Direct messaging from producers to consumers](ch11.md)
- Brubeck (metrics aggregator), [Direct messaging from producers to consumers](ch11.md)
- BTM (transaction coordinator), [Introduction to two-phase commit](ch09.md)
- bulk synchronous parallel (BSP) model, [The Pregel processing model](ch10.md)
- bursty network traffic patterns, [Can we not simply make network delays predictable?](ch08.md)
- business data processing, [Relational Model Versus Document Model](ch02.md), [Transaction Processing or Analytics?](ch03.md), [Batch Processing](ch10.md)
- byte sequence, encoding data in, [Formats for Encoding Data](ch04.md)
- Byzantine faults, [Byzantine Faults](ch08.md)-[Weak forms of lying](ch08.md), [System Model and Reality](ch08.md), [Glossary](glossary01.md)
  
  - Byzantine fault-tolerant systems, [Byzantine Faults](ch08.md), [Tools for auditable data systems](ch12.md)
  - Byzantine Generals Problem, [Byzantine Faults](ch08.md)
  - consensus algorithms and, [Fault-Tolerant Consensus](ch09.md)

### C

- caches, [Keeping everything in memory](ch03.md), [Glossary](glossary01.md)
  
  - and materialized views, [Aggregation: Data Cubes and Materialized Views](ch03.md)
  - as derived data, [Derived Data](part03.md), [Composing Data Storage Technologies](ch12.md)-[What’s missing?](ch12.md)
  - database as cache of transaction log, [State, Streams, and Immutability](ch11.md)
  - in CPUs, [Memory bandwidth and vectorized processing](ch03.md), [Linearizability and network delays](ch09.md), [The move toward declarative query languages](ch10.md)
  - invalidation and maintenance, [Keeping Systems in Sync](ch11.md), [Maintaining materialized views](ch11.md)
  - linearizability, [Linearizability](ch09.md)
- CAP theorem, [The CAP theorem](ch09.md)-[The CAP theorem](ch09.md), [Glossary](glossary01.md)
- Cascading (batch processing), [Beyond MapReduce](ch10.md), [High-Level APIs and Languages](ch10.md)
  
  - hash joins, [Broadcast hash joins](ch10.md)
  - workflows, [MapReduce workflows](ch10.md)
- cascading failures, [Software Errors](ch01.md), [Operations: Automatic or Manual Rebalancing](ch06.md), [Timeouts and Unbounded Delays](ch08.md)
- Cascalog (batch processing), [The Foundation: Datalog](ch02.md)
- Cassandra (database)
  
  - column-family data model, [Data locality for queries](ch02.md), [Column Compression](ch03.md)
  - compaction strategy, [Performance optimizations](ch03.md)
  - compound primary key, [Partitioning by Hash of Key](ch06.md)
  - gossip protocol, [Request Routing](ch06.md)
  - hash partitioning, [Partitioning by Hash of Key](ch06.md)-[Partitioning by Hash of Key](ch06.md)
  - last-write-wins conflict resolution, [Last write wins (discarding concurrent writes)](ch05.md), [Timestamps for ordering events](ch08.md)
  - leaderless replication, [Leaderless Replication](ch05.md)
  - linearizability, lack of, [Linearizability and quorums](ch09.md)
  - log-structured storage, [Making an LSM-tree out of SSTables](ch03.md)
  - multi-datacenter support, [Multi-datacenter operation](ch05.md)
  - partitioning scheme, [Partitioning proportionally to nodes](ch06.md)
  - secondary indexes, [Partitioning Secondary Indexes by Document](ch06.md)
  - sloppy quorums, [Sloppy Quorums and Hinted Handoff](ch05.md)
- cat (Unix tool), [Simple Log Analysis](ch10.md)
- causal context, [Version vectors](ch05.md)
  
  - (see also causal dependencies)
- causal dependencies, [The “happens-before” relationship and concurrency](ch05.md)-[Version vectors](ch05.md)
  
  - capturing, [Version vectors](ch05.md), [Capturing causal dependencies](ch09.md), [Ordering events to capture causality](ch12.md), [Reads are events too](ch12.md)
    
    - by total ordering, [The limits of total ordering](ch12.md)
  - causal ordering, [Ordering and Causality](ch09.md)
  - in transactions, [Decisions based on an outdated premise](ch07.md)
  - sending message to friends (example), [Ordering events to capture causality](ch12.md)
- causality, [Glossary](glossary01.md)
  
  - causal ordering, [Ordering and Causality](ch09.md)-[Capturing causal dependencies](ch09.md)
    
    - linearizability and, [Linearizability is stronger than causal consistency](ch09.md)
    - total order consistent with, [Sequence Number Ordering](ch09.md), [Lamport timestamps](ch09.md)
  - consistency with, [Sequence Number Ordering](ch09.md)-[Lamport timestamps](ch09.md)
  - consistent snapshots, [Ordering and Causality](ch09.md)
  - happens-before relationship, [The “happens-before” relationship and concurrency](ch05.md)
  - in serializable transactions, [Decisions based on an outdated premise](ch07.md)-[Detecting writes that affect prior reads](ch07.md)
  - mismatch with clocks, [Timestamps for ordering events](ch08.md)
  - ordering events to capture, [Ordering events to capture causality](ch12.md)
  - violations of, [Consistent Prefix Reads](ch05.md), [Multi-Leader Replication Topologies](ch05.md), [Timestamps for ordering events](ch08.md), [Ordering and Causality](ch09.md)
  - with synchronized clocks, [Synchronized clocks for global snapshots](ch08.md)
- CEP (see complex event processing)
- certificate transparency, [Tools for auditable data systems](ch12.md)
- chain replication, [Synchronous Versus Asynchronous Replication](ch05.md)
  
  - linearizable reads, [Implementing linearizable storage using total order broadcast](ch09.md)
- change data capture, [Logical (row-based) log replication](ch05.md), [Change Data Capture](ch11.md)
  
  - API support for change streams, [API support for change streams](ch11.md)
  - comparison to event sourcing, [Event Sourcing](ch11.md)
  - implementing, [Implementing change data capture](ch11.md)
  - initial snapshot, [Initial snapshot](ch11.md)
  - log compaction, [Log compaction](ch11.md)
- changelogs, [State, Streams, and Immutability](ch11.md)
  
  - change data capture, [Change Data Capture](ch11.md)
  - for operator state, [Rebuilding state after a failure](ch11.md)
  - generating with triggers, [Implementing change data capture](ch11.md)
  - in stream joins, [Stream-table join (stream enrichment)](ch11.md)
  - log compaction, [Log compaction](ch11.md)
  - maintaining derived state, [Databases and Streams](ch11.md)
- Chaos Monkey, [Reliability](ch01.md), [Network Faults in Practice](ch08.md)
- checkpointing
  
  - in batch processors, [Fault tolerance](ch10.md), [Fault tolerance](ch10.md)
  - in high-performance computing, [Cloud Computing and Supercomputing](ch08.md)
  - in stream processors, [Microbatching and checkpointing](ch11.md), [Multi-partition request processing](ch12.md)
- chronicle data model, [Event Sourcing](ch11.md)
- circuit-switched networks, [Synchronous Versus Asynchronous Networks](ch08.md)
- circular buffers, [Disk space usage](ch11.md)
- circular replication topologies, [Multi-Leader Replication Topologies](ch05.md)
- clickstream data, analysis of, [Example: analysis of user activity events](ch10.md)
- clients
  
  - calling services, [Dataflow Through Services: REST and RPC](ch04.md)
  - pushing state changes to, [Pushing state changes to clients](ch12.md)
  - request routing, [Request Routing](ch06.md)
  - stateful and offline-capable, [Clients with offline operation](ch05.md), [Stateful, offline-capable clients](ch12.md)
- clocks, [Unreliable Clocks](ch08.md)-[Limiting the impact of garbage collection](ch08.md)
  
  - atomic (caesium) clocks, [Clock readings have a confidence interval](ch08.md), [Synchronized clocks for global snapshots](ch08.md)
  - confidence interval, [Clock readings have a confidence interval](ch08.md)-[Synchronized clocks for global snapshots](ch08.md)
  - for global snapshots, [Synchronized clocks for global snapshots](ch08.md)
  - logical (see logical clocks)
  - skew, [Relying on Synchronized Clocks](ch08.md)-[Clock readings have a confidence interval](ch08.md), [Implementing Linearizable Systems](ch09.md)
  - slewing, [Monotonic clocks](ch08.md)
  - synchronization and accuracy, [Clock Synchronization and Accuracy](ch08.md)-[Clock Synchronization and Accuracy](ch08.md)
  - synchronization using GPS, [Unreliable Clocks](ch08.md), [Clock Synchronization and Accuracy](ch08.md), [Clock readings have a confidence interval](ch08.md), [Synchronized clocks for global snapshots](ch08.md)
  - time-of-day versus monotonic clocks, [Monotonic Versus Time-of-Day Clocks](ch08.md)
  - timestamping events, [Whose clock are you using, anyway?](ch11.md)
- cloud computing, [Distributed Data](part02.md), [Cloud Computing and Supercomputing](ch08.md)
  
  - need for service discovery, [Service discovery](ch09.md)
  - network glitches, [Network Faults in Practice](ch08.md)
  - shared resources, [Network congestion and queueing](ch08.md)
  - single-machine reliability, [Hardware Faults](ch01.md)
- Cloudera Impala (see Impala)
- clustered indexes, [Storing values within the index](ch03.md)
- CODASYL model, [The network model](ch02.md)
  
  - (see also network model)
- code generation
  
  - with Avro, [Code generation and dynamically typed languages](ch04.md)
  - with Thrift and Protocol Buffers, [Thrift and Protocol Buffers](ch04.md)
  - with WSDL, [Web services](ch04.md)
- collaborative editing
  
  - multi-leader replication and, [Collaborative editing](ch05.md)
- column families (Bigtable), [Data locality for queries](ch02.md), [Column Compression](ch03.md)
- column-oriented storage, [Column-Oriented Storage](ch03.md)-[Writing to Column-Oriented Storage](ch03.md)
  
  - column compression, [Column Compression](ch03.md)
  - distinction between column families and, [Column Compression](ch03.md)
  - in batch processors, [The move toward declarative query languages](ch10.md)
  - Parquet, [Column-Oriented Storage](ch03.md), [Archival storage](ch04.md), [Philosophy of batch process outputs](ch10.md)
  - sort order in, [Sort Order in Column Storage](ch03.md)-[Several different sort orders](ch03.md)
  - vectorized processing, [Memory bandwidth and vectorized processing](ch03.md), [The move toward declarative query languages](ch10.md)
  - writing to, [Writing to Column-Oriented Storage](ch03.md)
- comma-separated values (see CSV)
- command query responsibility segregation (CQRS), [Deriving several views from the same event log](ch11.md)
- commands (event sourcing), [Commands and events](ch11.md)
- commits (transactions), [Transactions](ch07.md)
  
  - atomic commit, [Atomic Commit and Two-Phase Commit (2PC)](ch09.md)-[From single-node to distributed atomic commit](ch09.md)
    
    - (see also atomicity; transactions)
  - read committed isolation, [Read Committed](ch07.md)
  - three-phase commit (3PC), [Three-phase commit](ch09.md)
  - two-phase commit (2PC), [Introduction to two-phase commit](ch09.md)-[Coordinator failure](ch09.md)
- commutative operations, [Conflict resolution and replication](ch07.md)
- compaction
  
  - of changelogs, [Log compaction](ch11.md)
    
    - (see also log compaction)
    - for stream operator state, [Rebuilding state after a failure](ch11.md)
  - of log-structured storage, [Hash Indexes](ch03.md)
    
    - issues with, [Downsides of LSM-trees](ch03.md)
    - size-tiered and leveled approaches, [Performance optimizations](ch03.md)
- CompactProtocol encoding (Thrift), [Thrift and Protocol Buffers](ch04.md)
- compare-and-set operations, [Compare-and-set](ch07.md), [What Makes a System Linearizable?](ch09.md)
  
  - implementing locks, [Membership and Coordination Services](ch09.md)
  - implementing uniqueness constraints, [Constraints and uniqueness guarantees](ch09.md)
  - implementing with total order broadcast, [Implementing linearizable storage using total order broadcast](ch09.md)
  - relation to consensus, [Linearizability and quorums](ch09.md), [Implementing linearizable storage using total order broadcast](ch09.md), [Implementing total order broadcast using linearizable storage](ch09.md), [Summary](ch09.md)
  - relation to transactions, [Single-object writes](ch07.md)
- compatibility, [Encoding and Evolution](ch04.md), [Modes of Dataflow](ch04.md)
  
  - calling services, [Data encoding and evolution for RPC](ch04.md)
  - properties of encoding formats, [Summary](ch04.md)
  - using databases, [Dataflow Through Databases](ch04.md)-[Archival storage](ch04.md)
  - using message-passing, [Distributed actor frameworks](ch04.md)
- compensating transactions, [From single-node to distributed atomic commit](ch09.md), [Advantages of immutable events](ch11.md), [Loosely interpreted constraints](ch12.md)
- complex event processing (CEP), [Complex event processing](ch11.md)
- complexity
  
  - distilling in theoretical models, [Mapping system models to the real world](ch08.md)
  - hiding using abstraction, [Data Models and Query Languages](ch02.md)
  - of software systems, managing, [Simplicity: Managing Complexity](ch01.md)
- composing data systems (see unbundling databases)
- compute-intensive applications, [Reliable, Scalable, and Maintainable Applications](ch01.md), [Cloud Computing and Supercomputing](ch08.md)
- concatenated indexes, [Multi-column indexes](ch03.md)
  
  - in Cassandra, [Partitioning by Hash of Key](ch06.md)
- Concord (stream processor), [Stream analytics](ch11.md)
- concurrency
  
  - actor programming model, [Distributed actor frameworks](ch04.md), [Message passing and RPC](ch11.md)
    
    - (see also message-passing)
  - bugs from weak transaction isolation, [Weak Isolation Levels](ch07.md)
  - conflict resolution, [Handling Write Conflicts](ch05.md), [Custom conflict resolution logic](ch05.md)
  - detecting concurrent writes, [Detecting Concurrent Writes](ch05.md)-[Version vectors](ch05.md)
  - dual writes, problems with, [Keeping Systems in Sync](ch11.md)
  - happens-before relationship, [The “happens-before” relationship and concurrency](ch05.md)
  - in replicated systems, [Problems with Replication Lag](ch05.md)-[Version vectors](ch05.md), [Linearizability](ch09.md)-[Linearizability and network delays](ch09.md)
  - lost updates, [Preventing Lost Updates](ch07.md)
  - multi-version concurrency control (MVCC), [Implementing snapshot isolation](ch07.md)
  - optimistic concurrency control, [Pessimistic versus optimistic concurrency control](ch07.md)
  - ordering of operations, [What Makes a System Linearizable?](ch09.md), [The causal order is not a total order](ch09.md)
  - reducing, through event logs, [Implementing linearizable storage using total order broadcast](ch09.md), [Concurrency control](ch11.md), [Dataflow: Interplay between state changes and application code](ch12.md)
  - time and relativity, [The “happens-before” relationship and concurrency](ch05.md)
  - transaction isolation, [Isolation](ch07.md)
  - write skew (transaction isolation), [Write Skew and Phantoms](ch07.md)-[Materializing conflicts](ch07.md)
- conflict-free replicated datatypes (CRDTs), [Custom conflict resolution logic](ch05.md)
- conflicts
  
  - conflict detection, [Synchronous versus asynchronous conflict detection](ch05.md)
    
    - causal dependencies, [The “happens-before” relationship and concurrency](ch05.md), [Capturing causal dependencies](ch09.md)
    - in consensus algorithms, [Epoch numbering and quorums](ch09.md)
    - in leaderless replication, [Detecting Concurrent Writes](ch05.md)
    - in log-based systems, [Implementing linearizable storage using total order broadcast](ch09.md), [Uniqueness constraints require consensus](ch12.md)
    - in nonlinearizable systems, [Capturing causal dependencies](ch09.md)
    - in serializable snapshot isolation (SSI), [Detecting writes that affect prior reads](ch07.md)
    - in two-phase commit, [A system of promises](ch09.md), [Limitations of distributed transactions](ch09.md)
  - conflict resolution
    
    - automatic conflict resolution, [Custom conflict resolution logic](ch05.md)
    - by aborting transactions, [Pessimistic versus optimistic concurrency control](ch07.md)
    - by apologizing, [Loosely interpreted constraints](ch12.md)
    - convergence, [Converging toward a consistent state](ch05.md)-[Custom conflict resolution logic](ch05.md)
    - in leaderless systems, [Merging concurrently written values](ch05.md)
    - last write wins (LWW), [Last write wins (discarding concurrent writes)](ch05.md), [Timestamps for ordering events](ch08.md)
    - using atomic operations, [Conflict resolution and replication](ch07.md)
    - using custom logic, [Custom conflict resolution logic](ch05.md)
  - determining what is a conflict, [What is a conflict?](ch05.md), [Uniqueness in log-based messaging](ch12.md)
  - in multi-leader replication, [Handling Write Conflicts](ch05.md)-[What is a conflict?](ch05.md)
    
    - avoiding conflicts, [Conflict avoidance](ch05.md)
  - lost updates, [Preventing Lost Updates](ch07.md)-[Conflict resolution and replication](ch07.md)
  - materializing, [Materializing conflicts](ch07.md)
  - relation to operation ordering, [Ordering Guarantees](ch09.md)
  - write skew (transaction isolation), [Write Skew and Phantoms](ch07.md)-[Materializing conflicts](ch07.md)
- congestion (networks)
  
  - avoidance, [Network congestion and queueing](ch08.md)
  - limiting accuracy of clocks, [Clock readings have a confidence interval](ch08.md)
  - queueing delays, [Network congestion and queueing](ch08.md)
- consensus, [Consistency and Consensus](ch09.md), [Fault-Tolerant Consensus](ch09.md)-[Summary](ch09.md), [Glossary](glossary01.md)
  
  - algorithms, [Consensus algorithms and total order broadcast](ch09.md)-[Epoch numbering and quorums](ch09.md)
    
    - preventing split brain, [Single-leader replication and consensus](ch09.md)
    - safety and liveness properties, [Fault-Tolerant Consensus](ch09.md)
    - using linearizable operations, [Implementing total order broadcast using linearizable storage](ch09.md)
  - cost of, [Limitations of consensus](ch09.md)
  - distributed transactions, [Distributed Transactions and Consensus](ch09.md)-[Summary](ch09.md)
    
    - in practice, [Distributed Transactions in Practice](ch09.md)-[Limitations of distributed transactions](ch09.md)
    - two-phase commit, [Atomic Commit and Two-Phase Commit (2PC)](ch09.md)-[Three-phase commit](ch09.md)
    - XA transactions, [XA transactions](ch09.md)-[Limitations of distributed transactions](ch09.md)
  - impossibility of, [Distributed Transactions and Consensus](ch09.md)
  - membership and coordination services, [Membership and Coordination Services](ch09.md)-[Membership services](ch09.md)
  - relation to compare-and-set, [Linearizability and quorums](ch09.md), [Implementing linearizable storage using total order broadcast](ch09.md), [Implementing total order broadcast using linearizable storage](ch09.md), [Summary](ch09.md)
  - relation to replication, [Synchronous Versus Asynchronous Replication](ch05.md), [Using total order broadcast](ch09.md)
  - relation to uniqueness constraints, [Uniqueness constraints require consensus](ch12.md)
- consistency, [Consistency](ch07.md), [Timeliness and Integrity](ch12.md)
  
  - across different databases, [Leader failure: Failover](ch05.md), [Keeping Systems in Sync](ch11.md), [Deriving several views from the same event log](ch11.md), [Derived data versus distributed transactions](ch12.md)
  - causal, [Ordering and Causality](ch09.md)-[Timestamp ordering is not sufficient](ch09.md), [Ordering events to capture causality](ch12.md)
  - consistent prefix reads, [Consistent Prefix Reads](ch05.md)-[Consistent Prefix Reads](ch05.md)
  - consistent snapshots, [Setting Up New Followers](ch05.md), [Snapshot Isolation and Repeatable Read](ch07.md)-[Repeatable read and naming confusion](ch07.md), [Synchronized clocks for global snapshots](ch08.md), [Initial snapshot](ch11.md), [Creating an index](ch12.md)
    
    - (see also snapshots)
  - crash recovery, [Making B-trees reliable](ch03.md)
  - enforcing constraints (see constraints)
  - eventual, [Problems with Replication Lag](ch05.md), [Consistency Guarantees](ch09.md)
    
    - (see also eventual consistency)
  - in ACID transactions, [Consistency](ch07.md), [Maintaining integrity in the face of software bugs](ch12.md)
  - in CAP theorem, [The CAP theorem](ch09.md)
  - linearizability, [Linearizability](ch09.md)-[Linearizability and network delays](ch09.md)
  - meanings of, [Consistency](ch07.md)
  - monotonic reads, [Monotonic Reads](ch05.md)-[Monotonic Reads](ch05.md)
  - of secondary indexes, [The need for multi-object transactions](ch07.md), [Indexes and snapshot isolation](ch07.md), [Atomic Commit and Two-Phase Commit (2PC)](ch09.md), [Reasoning about dataflows](ch12.md), [Creating an index](ch12.md)
  - ordering guarantees, [Ordering Guarantees](ch09.md)-[Implementing total order broadcast using linearizable storage](ch09.md)
  - read-after-write, [Reading Your Own Writes](ch05.md)-[Reading Your Own Writes](ch05.md)
  - sequential, [Implementing linearizable storage using total order broadcast](ch09.md)
  - strong (see linearizability)
  - timeliness and integrity, [Timeliness and Integrity](ch12.md)
  - using quorums, [Limitations of Quorum Consistency](ch05.md), [Linearizability and quorums](ch09.md)
- consistent hashing, [Partitioning by Hash of Key](ch06.md)
- consistent prefix reads, [Consistent Prefix Reads](ch05.md)
- constraints (databases), [Consistency](ch07.md), [Characterizing write skew](ch07.md)
  
  - asynchronously checked, [Loosely interpreted constraints](ch12.md)
  - coordination avoidance, [Coordination-avoiding data systems](ch12.md)
  - ensuring idempotence, [Operation identifiers](ch12.md)
  - in log-based systems, [Enforcing Constraints](ch12.md)-[Multi-partition request processing](ch12.md)
    
    - across multiple partitions, [Multi-partition request processing](ch12.md)
  - in two-phase commit, [From single-node to distributed atomic commit](ch09.md), [A system of promises](ch09.md)
  - relation to consensus, [Summary](ch09.md), [Uniqueness constraints require consensus](ch12.md)
  - relation to event ordering, [Timestamp ordering is not sufficient](ch09.md)
  - requiring linearizability, [Constraints and uniqueness guarantees](ch09.md)
- Consul (service discovery), [Service discovery](ch09.md)
- consumers (message streams), [Message brokers](ch04.md), [Transmitting Event Streams](ch11.md)
  
  - backpressure, [Messaging Systems](ch11.md)
  - consumer offsets in logs, [Consumer offsets](ch11.md)
  - failures, [Acknowledgments and redelivery](ch11.md), [Consumer offsets](ch11.md)
  - fan-out, [Describing Load](ch01.md), [Multiple consumers](ch11.md), [Logs compared to traditional messaging](ch11.md)
  - load balancing, [Multiple consumers](ch11.md), [Logs compared to traditional messaging](ch11.md)
  - not keeping up with producers, [Messaging Systems](ch11.md), [Disk space usage](ch11.md), [Making unbundling work](ch12.md)
- context switches, [Describing Performance](ch01.md), [Process Pauses](ch08.md)
- convergence (conflict resolution), [Converging toward a consistent state](ch05.md)-[Custom conflict resolution logic](ch05.md), [Consistency Guarantees](ch09.md)
- coordination
  
  - avoidance, [Coordination-avoiding data systems](ch12.md)
  - cross-datacenter, [Multi-datacenter operation](ch05.md), [The limits of total ordering](ch12.md)
  - cross-partition ordering, [Partitioning](ch07.md), [Synchronized clocks for global snapshots](ch08.md), [Total Order Broadcast](ch09.md), [Multi-partition request processing](ch12.md)
  - services, [Locking and leader election](ch09.md), [Membership and Coordination Services](ch09.md)-[Membership services](ch09.md)
- coordinator (in 2PC), [Introduction to two-phase commit](ch09.md)
  
  - failure, [Coordinator failure](ch09.md)
  - in XA transactions, [XA transactions](ch09.md)-[Limitations of distributed transactions](ch09.md)
  - recovery, [Recovering from coordinator failure](ch09.md)
- copy-on-write (B-trees), [B-tree optimizations](ch03.md), [Indexes and snapshot isolation](ch07.md)
- CORBA (Common Object Request Broker Architecture), [The problems with remote procedure calls (RPCs)](ch04.md)
- correctness, [Thinking About Data Systems](ch01.md)
  
  - auditability, [Trust, but Verify](ch12.md)-[Tools for auditable data systems](ch12.md)
  - Byzantine fault tolerance, [Byzantine Faults](ch08.md), [Tools for auditable data systems](ch12.md)
  - dealing with partial failures, [Faults and Partial Failures](ch08.md)
  - in log-based systems, [Enforcing Constraints](ch12.md)-[Multi-partition request processing](ch12.md)
  - of algorithm within system model, [Correctness of an algorithm](ch08.md)
  - of compensating transactions, [From single-node to distributed atomic commit](ch09.md)
  - of consensus, [Epoch numbering and quorums](ch09.md)
  - of derived data, [The lambda architecture](ch12.md), [Designing for auditability](ch12.md)
  - of immutable data, [Advantages of immutable events](ch11.md)
  - of personal data, [Responsibility and accountability](ch12.md), [Privacy and use of data](ch12.md)
  - of time, [Multi-Leader Replication Topologies](ch05.md), [Clock Synchronization and Accuracy](ch08.md)-[Synchronized clocks for global snapshots](ch08.md)
  - of transactions, [Consistency](ch07.md), [Aiming for Correctness](ch12.md), [Maintaining integrity in the face of software bugs](ch12.md)
  - timeliness and integrity, [Timeliness and Integrity](ch12.md)-[Coordination-avoiding data systems](ch12.md)
- corruption of data
  
  - detecting, [The end-to-end argument](ch12.md), [Don’t just blindly trust what they promise](ch12.md)-[Tools for auditable data systems](ch12.md)
  - due to pathological memory access, [Trust, but Verify](ch12.md)
  - due to radiation, [Byzantine Faults](ch08.md)
  - due to split brain, [Leader failure: Failover](ch05.md), [The leader and the lock](ch08.md)
  - due to weak transaction isolation, [Weak Isolation Levels](ch07.md)
  - formalization in consensus, [Consensus algorithms and total order broadcast](ch09.md)
  - integrity as absence of, [Timeliness and Integrity](ch12.md)
  - network packets, [Weak forms of lying](ch08.md)
  - on disks, [Durability](ch07.md)
  - preventing using write-ahead logs, [Making B-trees reliable](ch03.md)
  - recovering from, [Philosophy of batch process outputs](ch10.md), [Advantages of immutable events](ch11.md)
- Couchbase (database)
  
  - durability, [Keeping everything in memory](ch03.md)
  - hash partitioning, [Partitioning by Hash of Key](ch06.md)-[Partitioning by Hash of Key](ch06.md), [Fixed number of partitions](ch06.md)
  - rebalancing, [Operations: Automatic or Manual Rebalancing](ch06.md)
  - request routing, [Request Routing](ch06.md)
- CouchDB (database)
  
  - B-tree storage, [Indexes and snapshot isolation](ch07.md)
  - change feed, [API support for change streams](ch11.md)
  - document data model, [The Object-Relational Mismatch](ch02.md)
  - join support, [Many-to-One and Many-to-Many Relationships](ch02.md)
  - MapReduce support, [MapReduce Querying](ch02.md), [Distributed execution of MapReduce](ch10.md)
  - replication, [Clients with offline operation](ch05.md), [Custom conflict resolution logic](ch05.md)
- covering indexes, [Storing values within the index](ch03.md)
- CPUs
  
  - cache coherence and memory barriers, [Linearizability and network delays](ch09.md)
  - caching and pipelining, [Memory bandwidth and vectorized processing](ch03.md), [The move toward declarative query languages](ch10.md)
  - increasing parallelism, [Query Languages for Data](ch02.md)
- CRDTs (see conflict-free replicated datatypes)
- CREATE INDEX statement (SQL), [Other Indexing Structures](ch03.md), [Creating an index](ch12.md)
- credit rating agencies, [Responsibility and accountability](ch12.md)
- Crunch (batch processing), [Beyond MapReduce](ch10.md), [High-Level APIs and Languages](ch10.md)
  
  - hash joins, [Broadcast hash joins](ch10.md)
  - sharded joins, [Handling skew](ch10.md)
  - workflows, [MapReduce workflows](ch10.md)
- cryptography
  
  - defense against attackers, [Byzantine Faults](ch08.md)
  - end-to-end encryption and authentication, [The end-to-end argument](ch12.md), [Legislation and self-regulation](ch12.md)
  - proving integrity of data, [Tools for auditable data systems](ch12.md)
- CSS (Cascading Style Sheets), [Declarative Queries on the Web](ch02.md)
- CSV (comma-separated values), [Data Structures That Power Your Database](ch03.md), [JSON, XML, and Binary Variants](ch04.md), [A uniform interface](ch10.md)
- Curator (ZooKeeper recipes), [Locking and leader election](ch09.md), [Allocating work to nodes](ch09.md)
- curl (Unix tool), [Current directions for RPC](ch04.md), [Separation of logic and wiring](ch10.md)
- cursor stability, [Atomic write operations](ch07.md)
- Cypher (query language), [The Cypher Query Language](ch02.md)
  
  - comparison to SPARQL, [The SPARQL query language](ch02.md)

### D

- data corruption (see corruption of data)
- data cubes, [Aggregation: Data Cubes and Materialized Views](ch03.md)
- data formats (see encoding)
- data integration, [Data Integration](ch12.md)-[Unifying batch and stream processing](ch12.md), [Summary](ch12.md)
  
  - batch and stream processing, [Batch and Stream Processing](ch12.md)-[Unifying batch and stream processing](ch12.md)
    
    - lambda architecture, [The lambda architecture](ch12.md)
    - maintaining derived state, [Maintaining derived state](ch12.md)
    - reprocessing data, [Reprocessing data for application evolution](ch12.md)
    - unifying, [Unifying batch and stream processing](ch12.md)
  - by unbundling databases, [Unbundling Databases](ch12.md)-[Multi-partition data processing](ch12.md)
    
    - comparison to federated databases, [The meta-database of everything](ch12.md)
  - combining tools by deriving data, [Combining Specialized Tools by Deriving Data](ch12.md)-[Ordering events to capture causality](ch12.md)
    
    - derived data versus distributed transactions, [Derived data versus distributed transactions](ch12.md)
    - limits of total ordering, [The limits of total ordering](ch12.md)
    - ordering events to capture causality, [Ordering events to capture causality](ch12.md)
    - reasoning about dataflows, [Reasoning about dataflows](ch12.md)
  - need for, [Derived Data](part03.md)
- data lakes, [Diversity of storage](ch10.md)
- data locality (see locality)
- data models, [Data Models and Query Languages](ch02.md)-[Summary](ch02.md)
  
  - graph-like models, [Graph-Like Data Models](ch02.md)-[The Foundation: Datalog](ch02.md)
    
    - Datalog language, [The Foundation: Datalog](ch02.md)-[The Foundation: Datalog](ch02.md)
    - property graphs, [Property Graphs](ch02.md)
    - RDF and triple-stores, [Triple-Stores and SPARQL](ch02.md)-[The SPARQL query language](ch02.md)
  - query languages, [Query Languages for Data](ch02.md)-[MapReduce Querying](ch02.md)
  - relational model versus document model, [Relational Model Versus Document Model](ch02.md)-[Convergence of document and relational databases](ch02.md)
- data protection regulations, [Legislation and self-regulation](ch12.md)
- data systems, [Reliable, Scalable, and Maintainable Applications](ch01.md)
  
  - about, [Thinking About Data Systems](ch01.md)
  - concerns when designing, [Thinking About Data Systems](ch01.md)
  - future of, [The Future of Data Systems](ch12.md)-[Summary](ch12.md)
    
    - correctness, constraints, and integrity, [Aiming for Correctness](ch12.md)-[Tools for auditable data systems](ch12.md)
    - data integration, [Data Integration](ch12.md)-[Unifying batch and stream processing](ch12.md)
    - unbundling databases, [Unbundling Databases](ch12.md)-[Multi-partition data processing](ch12.md)
  - heterogeneous, keeping in sync, [Keeping Systems in Sync](ch11.md)
  - maintainability, [Maintainability](ch01.md)-[Evolvability: Making Change Easy](ch01.md)
  - possible faults in, [Transactions](ch07.md)
  - reliability, [Reliability](ch01.md)-[How Important Is Reliability?](ch01.md)
    
    - hardware faults, [Hardware Faults](ch01.md)
    - human errors, [Human Errors](ch01.md)
    - importance of, [How Important Is Reliability?](ch01.md)
    - software errors, [Software Errors](ch01.md)
  - scalability, [Scalability](ch01.md)-[Approaches for Coping with Load](ch01.md)
  - unreliable clocks, [Unreliable Clocks](ch08.md)-[Limiting the impact of garbage collection](ch08.md)
- data warehousing, [Data Warehousing](ch03.md)-[Stars and Snowflakes: Schemas for Analytics](ch03.md), [Glossary](glossary01.md)
  
  - comparison to data lakes, [Diversity of storage](ch10.md)
  - ETL (extract-transform-load), [Data Warehousing](ch03.md), [Diversity of storage](ch10.md), [Keeping Systems in Sync](ch11.md)
  - keeping data systems in sync, [Keeping Systems in Sync](ch11.md)
  - schema design, [Stars and Snowflakes: Schemas for Analytics](ch03.md)
  - slowly changing dimension (SCD), [Time-dependence of joins](ch11.md)
- data-intensive applications, [Reliable, Scalable, and Maintainable Applications](ch01.md)
- database triggers (see triggers)
- database-internal distributed transactions, [Distributed Transactions in Practice](ch09.md), [Limitations of distributed transactions](ch09.md), [Atomic commit revisited](ch11.md)
- databases
  
  - archival storage, [Archival storage](ch04.md)
  - comparison of message brokers to, [Message brokers compared to databases](ch11.md)
  - dataflow through, [Dataflow Through Databases](ch04.md)
  - end-to-end argument for, [The end-to-end argument](ch12.md)-[Applying end-to-end thinking in data systems](ch12.md)
    
    - checking integrity, [The end-to-end argument again](ch12.md)
  - inside-out, [Designing Applications Around Dataflow](ch12.md)
    
    - (see also unbundling databases)
  - output from batch workflows, [Key-value stores as batch process output](ch10.md)
  - relation to event streams, [Databases and Streams](ch11.md)-[Limitations of immutability](ch11.md)
    
    - (see also changelogs)
    - API support for change streams, [API support for change streams](ch11.md), [Separation of application code and state](ch12.md)
    - change data capture, [Change Data Capture](ch11.md)-[API support for change streams](ch11.md)
    - event sourcing, [Event Sourcing](ch11.md)-[Commands and events](ch11.md)
    - keeping systems in sync, [Keeping Systems in Sync](ch11.md)-[Keeping Systems in Sync](ch11.md)
    - philosophy of immutable events, [State, Streams, and Immutability](ch11.md)-[Limitations of immutability](ch11.md)
  - unbundling, [Unbundling Databases](ch12.md)-[Multi-partition data processing](ch12.md)
    
    - composing data storage technologies, [Composing Data Storage Technologies](ch12.md)-[What’s missing?](ch12.md)
    - designing applications around dataflow, [Designing Applications Around Dataflow](ch12.md)-[Stream processors and services](ch12.md)
    - observing derived state, [Observing Derived State](ch12.md)-[Multi-partition data processing](ch12.md)
- datacenters
  
  - geographically distributed, [Distributed Data](part02.md), [Reading Your Own Writes](ch05.md), [Unreliable Networks](ch08.md), [The limits of total ordering](ch12.md)
  - multi-tenancy and shared resources, [Network congestion and queueing](ch08.md)
  - network architecture, [Cloud Computing and Supercomputing](ch08.md)
  - network faults, [Network Faults in Practice](ch08.md)
  - replication across multiple, [Multi-datacenter operation](ch05.md)
    
    - leaderless replication, [Multi-datacenter operation](ch05.md)
    - multi-leader replication, [Multi-datacenter operation](ch05.md), [The Cost of Linearizability](ch09.md)
- dataflow, [Modes of Dataflow](ch04.md)-[Distributed actor frameworks](ch04.md), [Designing Applications Around Dataflow](ch12.md)-[Stream processors and services](ch12.md)
  
  - correctness of dataflow systems, [Correctness of dataflow systems](ch12.md)
  - differential, [What’s missing?](ch12.md)
  - message-passing, [Message-Passing Dataflow](ch04.md)-[Distributed actor frameworks](ch04.md)
  - reasoning about, [Reasoning about dataflows](ch12.md)
  - through databases, [Dataflow Through Databases](ch04.md)
  - through services, [Dataflow Through Services: REST and RPC](ch04.md)-[Data encoding and evolution for RPC](ch04.md)
- dataflow engines, [Dataflow engines](ch10.md)-[Discussion of materialization](ch10.md)
  
  - comparison to stream processing, [Processing Streams](ch11.md)
  - directed acyclic graphs (DAG), [Graphs and Iterative Processing](ch10.md)
  - partitioning, approach to, [Summary](ch10.md)
  - support for declarative queries, [The move toward declarative query languages](ch10.md)
- Datalog (query language), [The Foundation: Datalog](ch02.md)-[The Foundation: Datalog](ch02.md)
- datatypes
  
  - binary strings in XML and JSON, [JSON, XML, and Binary Variants](ch04.md)
  - conflict-free, [Custom conflict resolution logic](ch05.md)
  - in Avro encodings, [Avro](ch04.md)
  - in Thrift and Protocol Buffers, [Datatypes and schema evolution](ch04.md)
  - numbers in XML and JSON, [JSON, XML, and Binary Variants](ch04.md)
- Datomic (database)
  
  - B-tree storage, [Indexes and snapshot isolation](ch07.md)
  - data model, [Graph-Like Data Models](ch02.md), [The semantic web](ch02.md)
  - Datalog query language, [The Foundation: Datalog](ch02.md)
  - excision (deleting data), [Limitations of immutability](ch11.md)
  - languages for transactions, [Pros and cons of stored procedures](ch07.md)
  - serial execution of transactions, [Actual Serial Execution](ch07.md)
- deadlocks
  
  - detection, in two-phase commit (2PC), [Limitations of distributed transactions](ch09.md)
  - in two-phase locking (2PL), [Implementation of two-phase locking](ch07.md)
- Debezium (change data capture), [Implementing change data capture](ch11.md)
- declarative languages, [Query Languages for Data](ch02.md), [Glossary](glossary01.md)
  
  - Bloom, [Designing Applications Around Dataflow](ch12.md)
  - CSS and XSL, [Declarative Queries on the Web](ch02.md)
  - Cypher, [The Cypher Query Language](ch02.md)
  - Datalog, [The Foundation: Datalog](ch02.md)
  - for batch processing, [The move toward declarative query languages](ch10.md)
  - recursive SQL queries, [Graph Queries in SQL](ch02.md)
  - relational algebra and SQL, [Query Languages for Data](ch02.md)
  - SPARQL, [The SPARQL query language](ch02.md)
- delays
  
  - bounded network delays, [Synchronous Versus Asynchronous Networks](ch08.md)
  - bounded process pauses, [Response time guarantees](ch08.md)
  - unbounded network delays, [Timeouts and Unbounded Delays](ch08.md)
  - unbounded process pauses, [Process Pauses](ch08.md)
- deleting data, [Limitations of immutability](ch11.md)
- denormalization (data representation), [Many-to-One and Many-to-Many Relationships](ch02.md), [Glossary](glossary01.md)
  
  - costs, [Which data model leads to simpler application code?](ch02.md)
  - in derived data systems, [Derived Data](part03.md)
  - materialized views, [Aggregation: Data Cubes and Materialized Views](ch03.md)
  - updating derived data, [Single-Object and Multi-Object Operations](ch07.md), [The need for multi-object transactions](ch07.md), [Combining Specialized Tools by Deriving Data](ch12.md)
  - versus normalization, [Deriving several views from the same event log](ch11.md)
- derived data, [Derived Data](part03.md), [Stream Processing](ch11.md), [Glossary](glossary01.md)
  
  - from change data capture, [Implementing change data capture](ch11.md)
  - in event sourcing, [Deriving current state from the event log](ch11.md)-[Deriving current state from the event log](ch11.md)
  - maintaining derived state through logs, [Databases and Streams](ch11.md)-[API support for change streams](ch11.md), [State, Streams, and Immutability](ch11.md)-[Concurrency control](ch11.md)
  - observing, by subscribing to streams, [End-to-end event streams](ch12.md)
  - outputs of batch and stream processing, [Batch and Stream Processing](ch12.md)
  - through application code, [Application code as a derivation function](ch12.md)
  - versus distributed transactions, [Derived data versus distributed transactions](ch12.md)
- deterministic operations, [Pros and cons of stored procedures](ch07.md), [Faults and Partial Failures](ch08.md), [Glossary](glossary01.md)
  
  - accidental nondeterminism, [Fault tolerance](ch10.md)
  - and fault tolerance, [Fault tolerance](ch10.md), [Fault tolerance](ch10.md)
  - and idempotence, [Idempotence](ch11.md), [Reasoning about dataflows](ch12.md)
  - computing derived data, [Maintaining derived state](ch12.md), [Correctness of dataflow systems](ch12.md), [Designing for auditability](ch12.md)
  - in state machine replication, [Using total order broadcast](ch09.md), [Databases and Streams](ch11.md), [Deriving current state from the event log](ch11.md)
  - joins, [Time-dependence of joins](ch11.md)
- DevOps, [The Unix Philosophy](ch10.md)
- differential dataflow, [What’s missing?](ch12.md)
- dimension tables, [Stars and Snowflakes: Schemas for Analytics](ch03.md)
- dimensional modeling (see star schemas)
- directed acyclic graphs (DAGs), [Graphs and Iterative Processing](ch10.md)
- dirty reads (transaction isolation), [No dirty reads](ch07.md)
- dirty writes (transaction isolation), [No dirty writes](ch07.md)
- discrimination, [Bias and discrimination](ch12.md)
- disks (see hard disks)
- distributed actor frameworks, [Distributed actor frameworks](ch04.md)
- distributed filesystems, [MapReduce and Distributed Filesystems](ch10.md)-[MapReduce and Distributed Filesystems](ch10.md)
  
  - decoupling from query engines, [Diversity of processing models](ch10.md)
  - indiscriminately dumping data into, [Diversity of storage](ch10.md)
  - use by MapReduce, [MapReduce workflows](ch10.md)
- distributed systems, [The Trouble with Distributed Systems](ch08.md)-[Summary](ch08.md), [Glossary](glossary01.md)
  
  - Byzantine faults, [Byzantine Faults](ch08.md)-[Weak forms of lying](ch08.md)
  - cloud versus supercomputing, [Cloud Computing and Supercomputing](ch08.md)
  - detecting network faults, [Detecting Faults](ch08.md)
  - faults and partial failures, [Faults and Partial Failures](ch08.md)-[Cloud Computing and Supercomputing](ch08.md)
  - formalization of consensus, [Fault-Tolerant Consensus](ch09.md)
  - impossibility results, [The CAP theorem](ch09.md), [Distributed Transactions and Consensus](ch09.md)
  - issues with failover, [Leader failure: Failover](ch05.md)
  - limitations of distributed transactions, [Limitations of distributed transactions](ch09.md)
  - multi-datacenter, [Multi-datacenter operation](ch05.md), [The Cost of Linearizability](ch09.md)
  - network problems, [Unreliable Networks](ch08.md)-[Can we not simply make network delays predictable?](ch08.md)
  - quorums, relying on, [The Truth Is Defined by the Majority](ch08.md)
  - reasons for using, [Distributed Data](part02.md), [Replication](ch05.md)
  - synchronized clocks, relying on, [Relying on Synchronized Clocks](ch08.md)-[Synchronized clocks for global snapshots](ch08.md)
  - system models, [System Model and Reality](ch08.md)-[Mapping system models to the real world](ch08.md)
  - use of clocks and time, [Unreliable Clocks](ch08.md)
- distributed transactions (see transactions)
- Django (web framework), [Handling errors and aborts](ch07.md)
- DNS (Domain Name System), [Request Routing](ch06.md), [Service discovery](ch09.md)
- Docker (container manager), [Separation of application code and state](ch12.md)
- document data model, [The Object-Relational Mismatch](ch02.md)-[Convergence of document and relational databases](ch02.md)
  
  - comparison to relational model, [Relational Versus Document Databases Today](ch02.md)-[Convergence of document and relational databases](ch02.md)
  - document references, [Comparison to document databases](ch02.md), [Reduce-Side Joins and Grouping](ch10.md)
  - document-oriented databases, [The Object-Relational Mismatch](ch02.md)
  - many-to-many relationships and joins, [Are Document Databases Repeating History?](ch02.md)
  - multi-object transactions, need for, [The need for multi-object transactions](ch07.md)
  - versus relational model
    
    - convergence of models, [Convergence of document and relational databases](ch02.md)
    - data locality, [Data locality for queries](ch02.md)
- document-partitioned indexes, [Partitioning Secondary Indexes by Document](ch06.md), [Summary](ch06.md), [Building search indexes](ch10.md)
- domain-driven design (DDD), [Event Sourcing](ch11.md)
- DRBD (Distributed Replicated Block Device), [Leaders and Followers](ch05.md)
- drift (clocks), [Clock Synchronization and Accuracy](ch08.md)
- Drill (query engine), [The divergence between OLTP databases and data warehouses](ch03.md)
- Druid (database), [Deriving several views from the same event log](ch11.md)
- Dryad (dataflow engine), [Dataflow engines](ch10.md)
- dual writes, problems with, [Keeping Systems in Sync](ch11.md), [Dataflow: Interplay between state changes and application code](ch12.md)
- duplicates, suppression of, [Duplicate suppression](ch12.md)
  
  - (see also idempotence)
  - using a unique ID, [Operation identifiers](ch12.md), [Multi-partition request processing](ch12.md)
- durability (transactions), [Durability](ch07.md), [Glossary](glossary01.md)
- duration (time), [Unreliable Clocks](ch08.md)
  
  - measurement with monotonic clocks, [Monotonic clocks](ch08.md)
- dynamic partitioning, [Dynamic partitioning](ch06.md)
- dynamically typed languages
  
  - analogy to schema-on-read, [Schema flexibility in the document model](ch02.md)
  - code generation and, [Code generation and dynamically typed languages](ch04.md)
- Dynamo-style databases (see leaderless replication)

### E

- edges (in graphs), [Graph-Like Data Models](ch02.md), [Reduce-Side Joins and Grouping](ch10.md)
  
  - property graph model, [Property Graphs](ch02.md)
- edit distance (full-text search), [Full-text search and fuzzy indexes](ch03.md)
- effectively-once semantics, [Fault Tolerance](ch11.md), [Exactly-once execution of an operation](ch12.md)
  
  - (see also exactly-once semantics)
  - preservation of integrity, [Correctness of dataflow systems](ch12.md)
- elastic systems, [Approaches for Coping with Load](ch01.md)
- Elasticsearch (search server)
  
  - document-partitioned indexes, [Partitioning Secondary Indexes by Document](ch06.md)
  - partition rebalancing, [Fixed number of partitions](ch06.md)
  - percolator (stream search), [Search on streams](ch11.md)
  - usage example, [Thinking About Data Systems](ch01.md)
  - use of Lucene, [Making an LSM-tree out of SSTables](ch03.md)
- ElephantDB (database), [Key-value stores as batch process output](ch10.md)
- Elm (programming language), [Designing Applications Around Dataflow](ch12.md), [End-to-end event streams](ch12.md)
- encodings (data formats), [Encoding and Evolution](ch04.md)-[The Merits of Schemas](ch04.md)
  
  - Avro, [Avro](ch04.md)-[Code generation and dynamically typed languages](ch04.md)
  - binary variants of JSON and XML, [Binary encoding](ch04.md)
  - compatibility, [Encoding and Evolution](ch04.md)
    
    - calling services, [Data encoding and evolution for RPC](ch04.md)
    - using databases, [Dataflow Through Databases](ch04.md)-[Archival storage](ch04.md)
    - using message-passing, [Distributed actor frameworks](ch04.md)
  - defined, [Formats for Encoding Data](ch04.md)
  - JSON, XML, and CSV, [JSON, XML, and Binary Variants](ch04.md)
  - language-specific formats, [Language-Specific Formats](ch04.md)
  - merits of schemas, [The Merits of Schemas](ch04.md)
  - representations of data, [Formats for Encoding Data](ch04.md)
  - Thrift and Protocol Buffers, [Thrift and Protocol Buffers](ch04.md)-[Datatypes and schema evolution](ch04.md)
- end-to-end argument, [Cloud Computing and Supercomputing](ch08.md), [The end-to-end argument](ch12.md)-[Applying end-to-end thinking in data systems](ch12.md)
  
  - checking integrity, [The end-to-end argument again](ch12.md)
  - publish/subscribe streams, [End-to-end event streams](ch12.md)
- enrichment (stream), [Stream-table join (stream enrichment)](ch11.md)
- Enterprise JavaBeans (EJB), [The problems with remote procedure calls (RPCs)](ch04.md)
- entities (see vertices)
- epoch (consensus algorithms), [Epoch numbering and quorums](ch09.md)
- epoch (Unix timestamps), [Time-of-day clocks](ch08.md)
- equi-joins, [Reduce-Side Joins and Grouping](ch10.md)
- erasure coding (error correction), [MapReduce and Distributed Filesystems](ch10.md)
- Erlang OTP (actor framework), [Distributed actor frameworks](ch04.md)
- error handling
  
  - for network faults, [Network Faults in Practice](ch08.md)
  - in transactions, [Handling errors and aborts](ch07.md)
- error-correcting codes, [Cloud Computing and Supercomputing](ch08.md), [MapReduce and Distributed Filesystems](ch10.md)
- Esper (CEP engine), [Complex event processing](ch11.md)
- etcd (coordination service), [Membership and Coordination Services](ch09.md)-[Membership services](ch09.md)
  
  - linearizable operations, [Implementing Linearizable Systems](ch09.md)
  - locks and leader election, [Locking and leader election](ch09.md)
  - quorum reads, [Implementing linearizable storage using total order broadcast](ch09.md)
  - service discovery, [Service discovery](ch09.md)
  - use of Raft algorithm, [Using total order broadcast](ch09.md), [Distributed Transactions and Consensus](ch09.md)
- Ethereum (blockchain), [Tools for auditable data systems](ch12.md)
- Ethernet (networks), [Cloud Computing and Supercomputing](ch08.md), [Unreliable Networks](ch08.md), [Can we not simply make network delays predictable?](ch08.md)
  
  - packet checksums, [Weak forms of lying](ch08.md), [The end-to-end argument](ch12.md)
- Etherpad (collaborative editor), [Collaborative editing](ch05.md)
- ethics, [Doing the Right Thing](ch12.md)-[Legislation and self-regulation](ch12.md)
  
  - code of ethics and professional practice, [Doing the Right Thing](ch12.md)
  - legislation and self-regulation, [Legislation and self-regulation](ch12.md)
  - predictive analytics, [Predictive Analytics](ch12.md)-[Feedback loops](ch12.md)
    
    - amplifying bias, [Bias and discrimination](ch12.md)
    - feedback loops, [Feedback loops](ch12.md)
  - privacy and tracking, [Privacy and Tracking](ch12.md)-[Legislation and self-regulation](ch12.md)
    
    - consent and freedom of choice, [Consent and freedom of choice](ch12.md)
    - data as assets and power, [Data as assets and power](ch12.md)
    - meaning of privacy, [Privacy and use of data](ch12.md)
    - surveillance, [Surveillance](ch12.md)
  - respect, dignity, and agency, [Legislation and self-regulation](ch12.md), [Summary](ch12.md)
  - unintended consequences, [Doing the Right Thing](ch12.md), [Feedback loops](ch12.md)
- ETL (extract-transform-load), [Data Warehousing](ch03.md), [Example: analysis of user activity events](ch10.md), [Keeping Systems in Sync](ch11.md), [Glossary](glossary01.md)
  
  - use of Hadoop for, [Diversity of storage](ch10.md)
- event sourcing, [Event Sourcing](ch11.md)-[Commands and events](ch11.md)
  
  - commands and events, [Commands and events](ch11.md)
  - comparison to change data capture, [Event Sourcing](ch11.md)
  - comparison to lambda architecture, [The lambda architecture](ch12.md)
  - deriving current state from event log, [Deriving current state from the event log](ch11.md)
  - immutability and auditability, [State, Streams, and Immutability](ch11.md), [Designing for auditability](ch12.md)
  - large, reliable data systems, [Operation identifiers](ch12.md), [Correctness of dataflow systems](ch12.md)
- Event Store (database), [Event Sourcing](ch11.md)
- event streams (see streams)
- events, [Transmitting Event Streams](ch11.md)
  
  - deciding on total order of, [The limits of total ordering](ch12.md)
  - deriving views from event log, [Deriving several views from the same event log](ch11.md)
  - difference to commands, [Commands and events](ch11.md)
  - event time versus processing time, [Event time versus processing time](ch11.md), [Microbatching and checkpointing](ch11.md), [Unifying batch and stream processing](ch12.md)
  - immutable, advantages of, [Advantages of immutable events](ch11.md), [Designing for auditability](ch12.md)
  - ordering to capture causality, [Ordering events to capture causality](ch12.md)
  - reads as, [Reads are events too](ch12.md)
  - stragglers, [Knowing when you’re ready](ch11.md), [The lambda architecture](ch12.md)
  - timestamp of, in stream processing, [Whose clock are you using, anyway?](ch11.md)
- EventSource (browser API), [Pushing state changes to clients](ch12.md)
- eventual consistency, [Replication](ch05.md), [Problems with Replication Lag](ch05.md), [Safety and liveness](ch08.md), [Consistency Guarantees](ch09.md)
  
  - (see also conflicts)
  - and perpetual inconsistency, [Timeliness and Integrity](ch12.md)
- evolvability, [Evolvability: Making Change Easy](ch01.md), [Encoding and Evolution](ch04.md)
  
  - calling services, [Data encoding and evolution for RPC](ch04.md)
  - graph-structured data, [Property Graphs](ch02.md)
  - of databases, [Schema flexibility in the document model](ch02.md), [Dataflow Through Databases](ch04.md)-[Archival storage](ch04.md), [Deriving several views from the same event log](ch11.md), [Reprocessing data for application evolution](ch12.md)
  - of message-passing, [Distributed actor frameworks](ch04.md)
  - reprocessing data, [Reprocessing data for application evolution](ch12.md), [Unifying batch and stream processing](ch12.md)
  - schema evolution in Avro, [The writer’s schema and the reader’s schema](ch04.md)
  - schema evolution in Thrift and Protocol Buffers, [Field tags and schema evolution](ch04.md)
  - schema-on-read, [Schema flexibility in the document model](ch02.md), [Encoding and Evolution](ch04.md), [The Merits of Schemas](ch04.md)
- exactly-once semantics, [Exactly-once message processing](ch09.md), [Fault Tolerance](ch11.md), [Exactly-once execution of an operation](ch12.md)
  
  - parity with batch processors, [Unifying batch and stream processing](ch12.md)
  - preservation of integrity, [Correctness of dataflow systems](ch12.md)
- exclusive mode (locks), [Implementation of two-phase locking](ch07.md)
- eXtended Architecture transactions (see XA transactions)
- extract-transform-load (see ETL)

### F

- Facebook
  
  - Presto (query engine), [The divergence between OLTP databases and data warehouses](ch03.md)
  - React, Flux, and Redux (user interface libraries), [End-to-end event streams](ch12.md)
  - social graphs, [Graph-Like Data Models](ch02.md)
  - Wormhole (change data capture), [Implementing change data capture](ch11.md)
- fact tables, [Stars and Snowflakes: Schemas for Analytics](ch03.md)
- failover, [Leader failure: Failover](ch05.md), [Glossary](glossary01.md)
  
  - (see also leader-based replication)
  - in leaderless replication, absence of, [Writing to the Database When a Node Is Down](ch05.md)
  - leader election, [The leader and the lock](ch08.md), [Total Order Broadcast](ch09.md), [Distributed Transactions and Consensus](ch09.md)
  - potential problems, [Leader failure: Failover](ch05.md)
- failures
  
  - amplification by distributed transactions, [Limitations of distributed transactions](ch09.md), [Maintaining derived state](ch12.md)
  - failure detection, [Detecting Faults](ch08.md)
    
    - automatic rebalancing causing cascading failures, [Operations: Automatic or Manual Rebalancing](ch06.md)
    - perfect failure detectors, [Three-phase commit](ch09.md)
    - timeouts and unbounded delays, [Timeouts and Unbounded Delays](ch08.md), [Network congestion and queueing](ch08.md)
    - using ZooKeeper, [Membership and Coordination Services](ch09.md)
  - faults versus, [Reliability](ch01.md)
  - partial failures in distributed systems, [Faults and Partial Failures](ch08.md)-[Cloud Computing and Supercomputing](ch08.md), [Summary](ch08.md)
- fan-out (messaging systems), [Describing Load](ch01.md), [Multiple consumers](ch11.md)
- fault tolerance, [Reliability](ch01.md)-[How Important Is Reliability?](ch01.md), [Glossary](glossary01.md)
  
  - abstractions for, [Consistency and Consensus](ch09.md)
  - formalization in consensus, [Fault-Tolerant Consensus](ch09.md)-[Limitations of consensus](ch09.md)
    
    - use of replication, [Single-leader replication and consensus](ch09.md)
  - human fault tolerance, [Philosophy of batch process outputs](ch10.md)
  - in batch processing, [Bringing related data together in the same place](ch10.md), [Philosophy of batch process outputs](ch10.md), [Fault tolerance](ch10.md), [Fault tolerance](ch10.md)
  - in log-based systems, [Applying end-to-end thinking in data systems](ch12.md), [Timeliness and Integrity](ch12.md)-[Correctness of dataflow systems](ch12.md)
  - in stream processing, [Fault Tolerance](ch11.md)-[Rebuilding state after a failure](ch11.md)
    
    - atomic commit, [Atomic commit revisited](ch11.md)
    - idempotence, [Idempotence](ch11.md)
    - maintaining derived state, [Maintaining derived state](ch12.md)
    - microbatching and checkpointing, [Microbatching and checkpointing](ch11.md)
    - rebuilding state after a failure, [Rebuilding state after a failure](ch11.md)
  - of distributed transactions, [XA transactions](ch09.md)-[Limitations of distributed transactions](ch09.md)
  - transaction atomicity, [Atomicity](ch07.md), [Atomic Commit and Two-Phase Commit (2PC)](ch09.md)-[Exactly-once message processing](ch09.md)
- faults, [Reliability](ch01.md)
  
  - Byzantine faults, [Byzantine Faults](ch08.md)-[Weak forms of lying](ch08.md)
  - failures versus, [Reliability](ch01.md)
  - handled by transactions, [Transactions](ch07.md)
  - handling in supercomputers and cloud computing, [Cloud Computing and Supercomputing](ch08.md)
  - hardware, [Hardware Faults](ch01.md)
  - in batch processing versus distributed databases, [Designing for frequent faults](ch10.md)
  - in distributed systems, [Faults and Partial Failures](ch08.md)-[Cloud Computing and Supercomputing](ch08.md)
  - introducing deliberately, [Reliability](ch01.md), [Network Faults in Practice](ch08.md)
  - network faults, [Network Faults in Practice](ch08.md)-[Detecting Faults](ch08.md)
    
    - asymmetric faults, [The Truth Is Defined by the Majority](ch08.md)
    - detecting, [Detecting Faults](ch08.md)
    - tolerance of, in multi-leader replication, [Multi-datacenter operation](ch05.md)
  - software errors, [Software Errors](ch01.md)
  - tolerating (see fault tolerance)
- federated databases, [The meta-database of everything](ch12.md)
- fence (CPU instruction), [Linearizability and network delays](ch09.md)
- fencing (preventing split brain), [Leader failure: Failover](ch05.md), [The leader and the lock](ch08.md)-[Fencing tokens](ch08.md)
  
  - generating fencing tokens, [Using total order broadcast](ch09.md), [Membership and Coordination Services](ch09.md)
  - properties of fencing tokens, [Correctness of an algorithm](ch08.md)
  - stream processors writing to databases, [Idempotence](ch11.md), [Exactly-once execution of an operation](ch12.md)
- Fibre Channel (networks), [MapReduce and Distributed Filesystems](ch10.md)
- field tags (Thrift and Protocol Buffers), [Thrift and Protocol Buffers](ch04.md)-[Field tags and schema evolution](ch04.md)
- file descriptors (Unix), [A uniform interface](ch10.md)
- financial data, [Advantages of immutable events](ch11.md)
- Firebase (database), [API support for change streams](ch11.md)
- Flink (processing framework), [Dataflow engines](ch10.md)-[Discussion of materialization](ch10.md)
  
  - dataflow APIs, [High-Level APIs and Languages](ch10.md)
  - fault tolerance, [Fault tolerance](ch10.md), [Microbatching and checkpointing](ch11.md), [Rebuilding state after a failure](ch11.md)
  - Gelly API (graph processing), [The Pregel processing model](ch10.md)
  - integration of batch and stream processing, [Batch and Stream Processing](ch12.md), [Unifying batch and stream processing](ch12.md)
  - machine learning, [Specialization for different domains](ch10.md)
  - query optimizer, [The move toward declarative query languages](ch10.md)
  - stream processing, [Stream analytics](ch11.md)
- flow control, [Network congestion and queueing](ch08.md), [Messaging Systems](ch11.md), [Glossary](glossary01.md)
- FLP result (on consensus), [Distributed Transactions and Consensus](ch09.md)
- FlumeJava (dataflow library), [MapReduce workflows](ch10.md), [High-Level APIs and Languages](ch10.md)
- followers, [Leaders and Followers](ch05.md), [Glossary](glossary01.md)
  
  - (see also leader-based replication)
- foreign keys, [Comparison to document databases](ch02.md), [Reduce-Side Joins and Grouping](ch10.md)
- forward compatibility, [Encoding and Evolution](ch04.md)
- forward decay (algorithm), [Describing Performance](ch01.md)
- Fossil (version control system), [Limitations of immutability](ch11.md)
  
  - shunning (deleting data), [Limitations of immutability](ch11.md)
- FoundationDB (database)
  
  - serializable transactions, [Serializable Snapshot Isolation (SSI)](ch07.md), [Performance of serializable snapshot isolation](ch07.md), [Limitations of distributed transactions](ch09.md)
- fractal trees, [B-tree optimizations](ch03.md)
- full table scans, [Reduce-Side Joins and Grouping](ch10.md)
- full-text search, [Glossary](glossary01.md)
  
  - and fuzzy indexes, [Full-text search and fuzzy indexes](ch03.md)
  - building search indexes, [Building search indexes](ch10.md)
  - Lucene storage engine, [Making an LSM-tree out of SSTables](ch03.md)
- functional reactive programming (FRP), [Designing Applications Around Dataflow](ch12.md)
- functional requirements, [Summary](ch01.md)
- futures (asynchronous operations), [Current directions for RPC](ch04.md)
- fuzzy search (see similarity search)

### G

- garbage collection
  
  - immutability and, [Limitations of immutability](ch11.md)
  - process pauses for, [Describing Performance](ch01.md), [Process Pauses](ch08.md)-[Limiting the impact of garbage collection](ch08.md), [The Truth Is Defined by the Majority](ch08.md)
    
    - (see also process pauses)
- genome analysis, [Summary](ch02.md), [Specialization for different domains](ch10.md)
- geographically distributed datacenters, [Distributed Data](part02.md), [Reading Your Own Writes](ch05.md), [Unreliable Networks](ch08.md), [The limits of total ordering](ch12.md)
- geospatial indexes, [Multi-column indexes](ch03.md)
- Giraph (graph processing), [The Pregel processing model](ch10.md)
- Git (version control system), [Custom conflict resolution logic](ch05.md), [The causal order is not a total order](ch09.md), [Limitations of immutability](ch11.md)
- GitHub, postmortems, [Leader failure: Failover](ch05.md), [Leader failure: Failover](ch05.md), [Mapping system models to the real world](ch08.md)
- global indexes (see term-partitioned indexes)
- GlusterFS (distributed filesystem), [MapReduce and Distributed Filesystems](ch10.md)
- GNU Coreutils (Linux), [Sorting versus in-memory aggregation](ch10.md)
- GoldenGate (change data capture), [Trigger-based replication](ch05.md), [Multi-datacenter operation](ch05.md), [Implementing change data capture](ch11.md)
  
  - (see also Oracle)
- Google
  
  - Bigtable (database)
    
    - data model (see Bigtable data model)
    - partitioning scheme, [Partitioning](ch06.md), [Partitioning by Key Range](ch06.md)
    - storage layout, [Making an LSM-tree out of SSTables](ch03.md)
  - Chubby (lock service), [Membership and Coordination Services](ch09.md)
  - Cloud Dataflow (stream processor), [Stream analytics](ch11.md), [Atomic commit revisited](ch11.md), [Unifying batch and stream processing](ch12.md)
    
    - (see also Beam)
  - Cloud Pub/Sub (messaging), [Message brokers compared to databases](ch11.md), [Using logs for message storage](ch11.md)
  - Docs (collaborative editor), [Collaborative editing](ch05.md)
  - Dremel (query engine), [The divergence between OLTP databases and data warehouses](ch03.md), [Column-Oriented Storage](ch03.md)
  - FlumeJava (dataflow library), [MapReduce workflows](ch10.md), [High-Level APIs and Languages](ch10.md)
  - GFS (distributed file system), [MapReduce and Distributed Filesystems](ch10.md)
  - gRPC (RPC framework), [Current directions for RPC](ch04.md)
  - MapReduce (batch processing), [Batch Processing](ch10.md)
    
    - (see also MapReduce)
    - building search indexes, [Building search indexes](ch10.md)
    - task preemption, [Designing for frequent faults](ch10.md)
  - Pregel (graph processing), [The Pregel processing model](ch10.md)
  - Spanner (see Spanner)
  - TrueTime (clock API), [Clock readings have a confidence interval](ch08.md)
- gossip protocol, [Request Routing](ch06.md)
- government use of data, [Data as assets and power](ch12.md)
- GPS (Global Positioning System)
  
  - use for clock synchronization, [Unreliable Clocks](ch08.md), [Clock Synchronization and Accuracy](ch08.md), [Clock readings have a confidence interval](ch08.md), [Synchronized clocks for global snapshots](ch08.md)
- GraphChi (graph processing), [Parallel execution](ch10.md)
- graphs, [Glossary](glossary01.md)
  
  - as data models, [Graph-Like Data Models](ch02.md)-[The Foundation: Datalog](ch02.md)
    
    - example of graph-structured data, [Graph-Like Data Models](ch02.md)
    - property graphs, [Property Graphs](ch02.md)
    - RDF and triple-stores, [Triple-Stores and SPARQL](ch02.md)-[The SPARQL query language](ch02.md)
    - versus the network model, [The SPARQL query language](ch02.md)
  - processing and analysis, [Graphs and Iterative Processing](ch10.md)-[Parallel execution](ch10.md)
    
    - fault tolerance, [Fault tolerance](ch10.md)
    - Pregel processing model, [The Pregel processing model](ch10.md)
  - query languages
    
    - Cypher, [The Cypher Query Language](ch02.md)
    - Datalog, [The Foundation: Datalog](ch02.md)-[The Foundation: Datalog](ch02.md)
    - recursive SQL queries, [Graph Queries in SQL](ch02.md)
    - SPARQL, [The SPARQL query language](ch02.md)-[The SPARQL query language](ch02.md)
- Gremlin (graph query language), [Graph-Like Data Models](ch02.md)
- grep (Unix tool), [Simple Log Analysis](ch10.md)
- GROUP BY clause (SQL), [GROUP BY](ch10.md)
- grouping records in MapReduce, [GROUP BY](ch10.md)
  
  - handling skew, [Handling skew](ch10.md)

### H

- Hadoop (data infrastructure)
  
  - comparison to distributed databases, [Batch Processing](ch10.md)
  - comparison to MPP databases, [Comparing Hadoop to Distributed Databases](ch10.md)-[Designing for frequent faults](ch10.md)
  - comparison to Unix, [Philosophy of batch process outputs](ch10.md)-[Philosophy of batch process outputs](ch10.md), [Unbundling Databases](ch12.md)
  - diverse processing models in ecosystem, [Diversity of processing models](ch10.md)
  - HDFS distributed filesystem (see HDFS)
  - higher-level tools, [MapReduce workflows](ch10.md)
  - join algorithms, [Reduce-Side Joins and Grouping](ch10.md)-[MapReduce workflows with map-side joins](ch10.md)
    
    - (see also MapReduce)
  - MapReduce (see MapReduce)
  - YARN (see YARN)
- happens-before relationship, [Ordering and Causality](ch09.md)
  
  - capturing, [Capturing the happens-before relationship](ch05.md)
  - concurrency and, [The “happens-before” relationship and concurrency](ch05.md)
- hard disks
  
  - access patterns, [Advantages of LSM-trees](ch03.md)
  - detecting corruption, [The end-to-end argument](ch12.md), [Don’t just blindly trust what they promise](ch12.md)
  - faults in, [Hardware Faults](ch01.md), [Durability](ch07.md)
  - sequential write throughput, [Hash Indexes](ch03.md), [Disk space usage](ch11.md)
- hardware faults, [Hardware Faults](ch01.md)
- hash indexes, [Hash Indexes](ch03.md)-[Hash Indexes](ch03.md)
  
  - broadcast hash joins, [Broadcast hash joins](ch10.md)
  - partitioned hash joins, [Partitioned hash joins](ch10.md)
- hash partitioning, [Partitioning by Hash of Key](ch06.md)-[Partitioning by Hash of Key](ch06.md), [Summary](ch06.md)
  
  - consistent hashing, [Partitioning by Hash of Key](ch06.md)
  - problems with hash mod N, [How not to do it: hash mod N](ch06.md)
  - range queries, [Partitioning by Hash of Key](ch06.md)
  - suitable hash functions, [Partitioning by Hash of Key](ch06.md)
  - with fixed number of partitions, [Fixed number of partitions](ch06.md)
- HAWQ (database), [Specialization for different domains](ch10.md)
- HBase (database)
  
  - bug due to lack of fencing, [The leader and the lock](ch08.md)
  - bulk loading, [Key-value stores as batch process output](ch10.md)
  - column-family data model, [Data locality for queries](ch02.md), [Column Compression](ch03.md)
  - dynamic partitioning, [Dynamic partitioning](ch06.md)
  - key-range partitioning, [Partitioning by Key Range](ch06.md)
  - log-structured storage, [Making an LSM-tree out of SSTables](ch03.md)
  - request routing, [Request Routing](ch06.md)
  - size-tiered compaction, [Performance optimizations](ch03.md)
  - use of HDFS, [Diversity of processing models](ch10.md)
  - use of ZooKeeper, [Membership and Coordination Services](ch09.md)
- HDFS (Hadoop Distributed File System), [MapReduce and Distributed Filesystems](ch10.md)-[MapReduce and Distributed Filesystems](ch10.md)
  
  - (see also distributed filesystems)
  - checking data integrity, [Don’t just blindly trust what they promise](ch12.md)
  - decoupling from query engines, [Diversity of processing models](ch10.md)
  - indiscriminately dumping data into, [Diversity of storage](ch10.md)
  - metadata about datasets, [MapReduce workflows with map-side joins](ch10.md)
  - NameNode, [MapReduce and Distributed Filesystems](ch10.md)
  - use by Flink, [Rebuilding state after a failure](ch11.md)
  - use by HBase, [Dynamic partitioning](ch06.md)
  - use by MapReduce, [MapReduce workflows](ch10.md)
- HdrHistogram (numerical library), [Describing Performance](ch01.md)
- head (Unix tool), [Simple Log Analysis](ch10.md)
- head vertex (property graphs), [Property Graphs](ch02.md)
- head-of-line blocking, [Describing Performance](ch01.md)
- heap files (databases), [Storing values within the index](ch03.md)
- Helix (cluster manager), [Request Routing](ch06.md)
- heterogeneous distributed transactions, [Distributed Transactions in Practice](ch09.md), [Limitations of distributed transactions](ch09.md)
- heuristic decisions (in 2PC), [Recovering from coordinator failure](ch09.md)
- Hibernate (object-relational mapper), [The Object-Relational Mismatch](ch02.md)
- hierarchical model, [Are Document Databases Repeating History?](ch02.md)
- high availability (see fault tolerance)
- high-frequency trading, [Clock Synchronization and Accuracy](ch08.md), [Limiting the impact of garbage collection](ch08.md)
- high-performance computing (HPC), [Cloud Computing and Supercomputing](ch08.md)
- hinted handoff, [Sloppy Quorums and Hinted Handoff](ch05.md)
- histograms, [Describing Performance](ch01.md)
- Hive (query engine), [Beyond MapReduce](ch10.md), [High-Level APIs and Languages](ch10.md)
  
  - for data warehouses, [The divergence between OLTP databases and data warehouses](ch03.md)
  - HCatalog and metastore, [MapReduce workflows with map-side joins](ch10.md)
  - map-side joins, [Broadcast hash joins](ch10.md)
  - query optimizer, [The move toward declarative query languages](ch10.md)
  - skewed joins, [Handling skew](ch10.md)
  - workflows, [MapReduce workflows](ch10.md)
- Hollerith machines, [Batch Processing](ch10.md)
- hopping windows (stream processing), [Types of windows](ch11.md)
  
  - (see also windows)
- horizontal scaling (see scaling out)
- HornetQ (messaging), [Message brokers](ch04.md), [Message brokers compared to databases](ch11.md)
  
  - distributed transaction support, [XA transactions](ch09.md)
- hot spots, [Partitioning of Key-Value Data](ch06.md)
  
  - due to celebrities, [Skewed Workloads and Relieving Hot Spots](ch06.md)
  - for time-series data, [Partitioning by Key Range](ch06.md)
  - in batch processing, [Handling skew](ch10.md)
  - relieving, [Skewed Workloads and Relieving Hot Spots](ch06.md)
- hot standbys (see leader-based replication)
- HTTP, use in APIs (see services)
- human errors, [Human Errors](ch01.md), [Network Faults in Practice](ch08.md), [Philosophy of batch process outputs](ch10.md)
- HyperDex (database), [Multi-column indexes](ch03.md)
- HyperLogLog (algorithm), [Stream analytics](ch11.md)

### I

- I/O operations, waiting for, [Process Pauses](ch08.md)
- IBM
  
  - DB2 (database)
    
    - distributed transaction support, [XA transactions](ch09.md)
    - recursive query support, [Graph Queries in SQL](ch02.md)
    - serializable isolation, [Repeatable read and naming confusion](ch07.md), [Implementation of two-phase locking](ch07.md)
    - XML and JSON support, [The Object-Relational Mismatch](ch02.md), [Convergence of document and relational databases](ch02.md)
  - electromechanical card-sorting machines, [Batch Processing](ch10.md)
  - IMS (database), [Are Document Databases Repeating History?](ch02.md)
    
    - imperative query APIs, [Declarative Queries on the Web](ch02.md)
  - InfoSphere Streams (CEP engine), [Complex event processing](ch11.md)
  - MQ (messaging), [Message brokers compared to databases](ch11.md)
    
    - distributed transaction support, [XA transactions](ch09.md)
  - System R (database), [The Slippery Concept of a Transaction](ch07.md)
  - WebSphere (messaging), [Message brokers](ch04.md)
- idempotence, [The problems with remote procedure calls (RPCs)](ch04.md), [Idempotence](ch11.md), [Glossary](glossary01.md)
  
  - by giving operations unique IDs, [Operation identifiers](ch12.md), [Multi-partition request processing](ch12.md)
  - idempotent operations, [Exactly-once execution of an operation](ch12.md)
- immutability
  
  - advantages of, [Advantages of immutable events](ch11.md), [Designing for auditability](ch12.md)
  - deriving state from event log, [State, Streams, and Immutability](ch11.md)-[Limitations of immutability](ch11.md)
  - for crash recovery, [Hash Indexes](ch03.md)
  - in B-trees, [B-tree optimizations](ch03.md), [Indexes and snapshot isolation](ch07.md)
  - in event sourcing, [Event Sourcing](ch11.md)
  - inputs to Unix commands, [Transparency and experimentation](ch10.md)
  - limitations of, [Limitations of immutability](ch11.md)
- Impala (query engine)
  
  - for data warehouses, [The divergence between OLTP databases and data warehouses](ch03.md)
  - hash joins, [Broadcast hash joins](ch10.md)
  - native code generation, [The move toward declarative query languages](ch10.md)
  - use of HDFS, [Diversity of processing models](ch10.md)
- impedance mismatch, [The Object-Relational Mismatch](ch02.md)
- imperative languages, [Query Languages for Data](ch02.md)
  
  - setting element styles (example), [Declarative Queries on the Web](ch02.md)
- in doubt (transaction status), [Coordinator failure](ch09.md)
  
  - holding locks, [Holding locks while in doubt](ch09.md)
  - orphaned transactions, [Recovering from coordinator failure](ch09.md)
- in-memory databases, [Keeping everything in memory](ch03.md)
  
  - durability, [Durability](ch07.md)
  - serial transaction execution, [Actual Serial Execution](ch07.md)
- incidents
  
  - cascading failures, [Software Errors](ch01.md)
  - crashes due to leap seconds, [Clock Synchronization and Accuracy](ch08.md)
  - data corruption and financial losses due to concurrency bugs, [Weak Isolation Levels](ch07.md)
  - data corruption on hard disks, [Durability](ch07.md)
  - data loss due to last-write-wins, [Converging toward a consistent state](ch05.md), [Timestamps for ordering events](ch08.md)
  - data on disks unreadable, [Mapping system models to the real world](ch08.md)
  - deleted items reappearing, [Custom conflict resolution logic](ch05.md)
  - disclosure of sensitive data due to primary key reuse, [Leader failure: Failover](ch05.md)
  - errors in transaction serializability, [Maintaining integrity in the face of software bugs](ch12.md)
  - gigabit network interface with 1 Kb/s throughput, [Summary](ch08.md)
  - network faults, [Network Faults in Practice](ch08.md)
  - network interface dropping only inbound packets, [Network Faults in Practice](ch08.md)
  - network partitions and whole-datacenter failures, [Faults and Partial Failures](ch08.md)
  - poor handling of network faults, [Network Faults in Practice](ch08.md)
  - sending message to ex-partner, [Ordering events to capture causality](ch12.md)
  - sharks biting undersea cables, [Network Faults in Practice](ch08.md)
  - split brain due to 1-minute packet delay, [Leader failure: Failover](ch05.md), [Network Faults in Practice](ch08.md)
  - vibrations in server rack, [Describing Performance](ch01.md)
  - violation of uniqueness constraint, [Maintaining integrity in the face of software bugs](ch12.md)
- indexes, [Data Structures That Power Your Database](ch03.md), [Glossary](glossary01.md)
  
  - and snapshot isolation, [Indexes and snapshot isolation](ch07.md)
  - as derived data, [Derived Data](part03.md), [Composing Data Storage Technologies](ch12.md)-[What’s missing?](ch12.md)
  - B-trees, [B-Trees](ch03.md)-[B-tree optimizations](ch03.md)
  - building in batch processes, [Building search indexes](ch10.md)
  - clustered, [Storing values within the index](ch03.md)
  - comparison of B-trees and LSM-trees, [Comparing B-Trees and LSM-Trees](ch03.md)-[Downsides of LSM-trees](ch03.md)
  - concatenated, [Multi-column indexes](ch03.md)
  - covering (with included columns), [Storing values within the index](ch03.md)
  - creating, [Creating an index](ch12.md)
  - full-text search, [Full-text search and fuzzy indexes](ch03.md)
  - geospatial, [Multi-column indexes](ch03.md)
  - hash, [Hash Indexes](ch03.md)-[Hash Indexes](ch03.md)
  - index-range locking, [Index-range locks](ch07.md)
  - multi-column, [Multi-column indexes](ch03.md)
  - partitioning and secondary indexes, [Partitioning and Secondary Indexes](ch06.md)-[Partitioning Secondary Indexes by Term](ch06.md), [Summary](ch06.md)
  - secondary, [Other Indexing Structures](ch03.md)
    
    - (see also secondary indexes)
    - problems with dual writes, [Keeping Systems in Sync](ch11.md), [Reasoning about dataflows](ch12.md)
  - SSTables and LSM-trees, [SSTables and LSM-Trees](ch03.md)-[Performance optimizations](ch03.md)
  - updating when data changes, [Keeping Systems in Sync](ch11.md), [Maintaining materialized views](ch11.md)
- Industrial Revolution, [Remembering the Industrial Revolution](ch12.md)
- InfiniBand (networks), [Can we not simply make network delays predictable?](ch08.md)
- InfiniteGraph (database), [Graph-Like Data Models](ch02.md)
- InnoDB (storage engine)
  
  - clustered index on primary key, [Storing values within the index](ch03.md)
  - not preventing lost updates, [Automatically detecting lost updates](ch07.md)
  - preventing write skew, [Characterizing write skew](ch07.md), [Implementation of two-phase locking](ch07.md)
  - serializable isolation, [Implementation of two-phase locking](ch07.md)
  - snapshot isolation support, [Snapshot Isolation and Repeatable Read](ch07.md)
- inside-out databases, [Designing Applications Around Dataflow](ch12.md)
  
  - (see also unbundling databases)
- integrating different data systems (see data integration)
- integrity, [Timeliness and Integrity](ch12.md)
  
  - coordination-avoiding data systems, [Coordination-avoiding data systems](ch12.md)
  - correctness of dataflow systems, [Correctness of dataflow systems](ch12.md)
  - in consensus formalization, [Fault-Tolerant Consensus](ch09.md)
  - integrity checks, [Don’t just blindly trust what they promise](ch12.md)
    
    - (see also auditing)
    - end-to-end, [The end-to-end argument](ch12.md), [The end-to-end argument again](ch12.md)
    - use of snapshot isolation, [Snapshot Isolation and Repeatable Read](ch07.md)
  - maintaining despite software bugs, [Maintaining integrity in the face of software bugs](ch12.md)
- Interface Definition Language (IDL), [Thrift and Protocol Buffers](ch04.md), [Avro](ch04.md)
- intermediate state, materialization of, [Materialization of Intermediate State](ch10.md)-[Discussion of materialization](ch10.md)
- internet services, systems for implementing, [Cloud Computing and Supercomputing](ch08.md)
- invariants, [Consistency](ch07.md)
  
  - (see also constraints)
- inversion of control, [Separation of logic and wiring](ch10.md)
- IP (Internet Protocol)
  
  - unreliability of, [Cloud Computing and Supercomputing](ch08.md)
- ISDN (Integrated Services Digital Network), [Synchronous Versus Asynchronous Networks](ch08.md)
- isolation (in transactions), [Isolation](ch07.md), [Single-Object and Multi-Object Operations](ch07.md), [Glossary](glossary01.md)
  
  - correctness and, [Aiming for Correctness](ch12.md)
  - for single-object writes, [Single-object writes](ch07.md)
  - serializability, [Serializability](ch07.md)-[Performance of serializable snapshot isolation](ch07.md)
    
    - actual serial execution, [Actual Serial Execution](ch07.md)-[Summary of serial execution](ch07.md)
    - serializable snapshot isolation (SSI), [Serializable Snapshot Isolation (SSI)](ch07.md)-[Performance of serializable snapshot isolation](ch07.md)
    - two-phase locking (2PL), [Two-Phase Locking (2PL)](ch07.md)-[Index-range locks](ch07.md)
  - violating, [Single-Object and Multi-Object Operations](ch07.md)
  - weak isolation levels, [Weak Isolation Levels](ch07.md)-[Materializing conflicts](ch07.md)
    
    - preventing lost updates, [Preventing Lost Updates](ch07.md)-[Conflict resolution and replication](ch07.md)
    - read committed, [Read Committed](ch07.md)-[Implementing read committed](ch07.md)
    - snapshot isolation, [Snapshot Isolation and Repeatable Read](ch07.md)-[Repeatable read and naming confusion](ch07.md)
- iterative processing, [Graphs and Iterative Processing](ch10.md)-[Parallel execution](ch10.md)

### J

- Java Database Connectivity (JDBC)
  
  - distributed transaction support, [XA transactions](ch09.md)
  - network drivers, [The Merits of Schemas](ch04.md)
- Java Enterprise Edition (EE), [The problems with remote procedure calls (RPCs)](ch04.md), [Introduction to two-phase commit](ch09.md), [XA transactions](ch09.md)
- Java Message Service (JMS), [Message brokers compared to databases](ch11.md)
  
  - (see also messaging systems)
  - comparison to log-based messaging, [Logs compared to traditional messaging](ch11.md), [Replaying old messages](ch11.md)
  - distributed transaction support, [XA transactions](ch09.md)
  - message ordering, [Acknowledgments and redelivery](ch11.md)
- Java Transaction API (JTA), [Introduction to two-phase commit](ch09.md), [XA transactions](ch09.md)
- Java Virtual Machine (JVM)
  
  - bytecode generation, [The move toward declarative query languages](ch10.md)
  - garbage collection pauses, [Process Pauses](ch08.md)
  - process reuse in batch processors, [Dataflow engines](ch10.md)
- JavaScript
  
  - in MapReduce querying, [MapReduce Querying](ch02.md)
  - setting element styles (example), [Declarative Queries on the Web](ch02.md)
  - use in advanced queries, [MapReduce Querying](ch02.md)
- Jena (RDF framework), [The RDF data model](ch02.md)
- Jepsen (fault tolerance testing), [Aiming for Correctness](ch12.md)
- jitter (network delay), [Network congestion and queueing](ch08.md)
- joins, [Glossary](glossary01.md)
  
  - by index lookup, [Reduce-Side Joins and Grouping](ch10.md)
  - expressing as relational operators, [The move toward declarative query languages](ch10.md)
  - in relational and document databases, [Many-to-One and Many-to-Many Relationships](ch02.md)
  - MapReduce map-side joins, [Map-Side Joins](ch10.md)-[MapReduce workflows with map-side joins](ch10.md)
    
    - broadcast hash joins, [Broadcast hash joins](ch10.md)
    - merge joins, [Map-side merge joins](ch10.md)
    - partitioned hash joins, [Partitioned hash joins](ch10.md)
  - MapReduce reduce-side joins, [Reduce-Side Joins and Grouping](ch10.md)-[Handling skew](ch10.md)
    
    - handling skew, [Handling skew](ch10.md)
    - sort-merge joins, [Sort-merge joins](ch10.md)
  - parallel execution of, [Comparing Hadoop to Distributed Databases](ch10.md)
  - secondary indexes and, [Other Indexing Structures](ch03.md)
  - stream joins, [Stream Joins](ch11.md)-[Time-dependence of joins](ch11.md)
    
    - stream-stream join, [Stream-stream join (window join)](ch11.md)
    - stream-table join, [Stream-table join (stream enrichment)](ch11.md)
    - table-table join, [Table-table join (materialized view maintenance)](ch11.md)
    - time-dependence of, [Time-dependence of joins](ch11.md)
  - support in document databases, [Convergence of document and relational databases](ch02.md)
- JOTM (transaction coordinator), [Introduction to two-phase commit](ch09.md)
- JSON
  
  - Avro schema representation, [Avro](ch04.md)
  - binary variants, [Binary encoding](ch04.md)
  - for application data, issues with, [JSON, XML, and Binary Variants](ch04.md)
  - in relational databases, [The Object-Relational Mismatch](ch02.md), [Convergence of document and relational databases](ch02.md)
  - representing a résumé (example), [The Object-Relational Mismatch](ch02.md)
- Juttle (query language), [Designing Applications Around Dataflow](ch12.md)

### K

- k-nearest neighbors, [Specialization for different domains](ch10.md)
- Kafka (messaging), [Message brokers](ch04.md), [Using logs for message storage](ch11.md)
  
  - Kafka Connect (database integration), [API support for change streams](ch11.md), [Deriving several views from the same event log](ch11.md)
  - Kafka Streams (stream processor), [Stream analytics](ch11.md), [Maintaining materialized views](ch11.md)
    
    - fault tolerance, [Rebuilding state after a failure](ch11.md)
  - leader-based replication, [Leaders and Followers](ch05.md)
  - log compaction, [Log compaction](ch11.md), [Maintaining materialized views](ch11.md)
  - message offsets, [Using logs for message storage](ch11.md), [Idempotence](ch11.md)
  - request routing, [Request Routing](ch06.md)
  - transaction support, [Atomic commit revisited](ch11.md)
  - usage example, [Thinking About Data Systems](ch01.md)
- Ketama (partitioning library), [Partitioning proportionally to nodes](ch06.md)
- key-value stores, [Data Structures That Power Your Database](ch03.md)
  
  - as batch process output, [Key-value stores as batch process output](ch10.md)
  - hash indexes, [Hash Indexes](ch03.md)-[Hash Indexes](ch03.md)
  - in-memory, [Keeping everything in memory](ch03.md)
  - partitioning, [Partitioning of Key-Value Data](ch06.md)-[Skewed Workloads and Relieving Hot Spots](ch06.md)
    
    - by hash of key, [Partitioning by Hash of Key](ch06.md), [Summary](ch06.md)
    - by key range, [Partitioning by Key Range](ch06.md), [Summary](ch06.md)
    - dynamic partitioning, [Dynamic partitioning](ch06.md)
    - skew and hot spots, [Skewed Workloads and Relieving Hot Spots](ch06.md)
- Kryo (Java), [Language-Specific Formats](ch04.md)
- Kubernetes (cluster manager), [Designing for frequent faults](ch10.md), [Separation of application code and state](ch12.md)

### L

- lambda architecture, [The lambda architecture](ch12.md)
- Lamport timestamps, [Lamport timestamps](ch09.md)
- Large Hadron Collider (LHC), [Summary](ch02.md)
- last write wins (LWW), [Converging toward a consistent state](ch05.md), [Implementing Linearizable Systems](ch09.md)
  
  - discarding concurrent writes, [Last write wins (discarding concurrent writes)](ch05.md)
  - problems with, [Timestamps for ordering events](ch08.md)
  - prone to lost updates, [Conflict resolution and replication](ch07.md)
- late binding, [Separation of logic and wiring](ch10.md)
- latency
  
  - instability under two-phase locking, [Performance of two-phase locking](ch07.md)
  - network latency and resource utilization, [Can we not simply make network delays predictable?](ch08.md)
  - response time versus, [Describing Performance](ch01.md)
  - tail latency, [Describing Performance](ch01.md), [Partitioning Secondary Indexes by Document](ch06.md)
- leader-based replication, [Leaders and Followers](ch05.md)-[Trigger-based replication](ch05.md)
  
  - (see also replication)
  - failover, [Leader failure: Failover](ch05.md), [The leader and the lock](ch08.md)
  - handling node outages, [Handling Node Outages](ch05.md)
  - implementation of replication logs
    
    - change data capture, [Change Data Capture](ch11.md)-[API support for change streams](ch11.md)
      
      - (see also changelogs)
    - statement-based, [Statement-based replication](ch05.md)
    - trigger-based replication, [Trigger-based replication](ch05.md)
    - write-ahead log (WAL) shipping, [Write-ahead log (WAL) shipping](ch05.md)
  - linearizability of operations, [Implementing Linearizable Systems](ch09.md)
  - locking and leader election, [Locking and leader election](ch09.md)
  - log sequence number, [Setting Up New Followers](ch05.md), [Consumer offsets](ch11.md)
  - read-scaling architecture, [Problems with Replication Lag](ch05.md)
  - relation to consensus, [Single-leader replication and consensus](ch09.md)
  - setting up new followers, [Setting Up New Followers](ch05.md)
  - synchronous versus asynchronous, [Synchronous Versus Asynchronous Replication](ch05.md)-[Synchronous Versus Asynchronous Replication](ch05.md)
- leaderless replication, [Leaderless Replication](ch05.md)-[Version vectors](ch05.md)
  
  - (see also replication)
  - detecting concurrent writes, [Detecting Concurrent Writes](ch05.md)-[Version vectors](ch05.md)
    
    - capturing happens-before relationship, [Capturing the happens-before relationship](ch05.md)
    - happens-before relationship and concurrency, [The “happens-before” relationship and concurrency](ch05.md)
    - last write wins, [Last write wins (discarding concurrent writes)](ch05.md)
    - merging concurrently written values, [Merging concurrently written values](ch05.md)
    - version vectors, [Version vectors](ch05.md)
  - multi-datacenter, [Multi-datacenter operation](ch05.md)
  - quorums, [Quorums for reading and writing](ch05.md)-[Limitations of Quorum Consistency](ch05.md)
    
    - consistency limitations, [Limitations of Quorum Consistency](ch05.md)-[Monitoring staleness](ch05.md), [Linearizability and quorums](ch09.md)
    - sloppy quorums and hinted handoff, [Sloppy Quorums and Hinted Handoff](ch05.md)
  - read repair and anti-entropy, [Read repair and anti-entropy](ch05.md)
- leap seconds, [Software Errors](ch01.md), [Clock Synchronization and Accuracy](ch08.md)
  
  - in time-of-day clocks, [Time-of-day clocks](ch08.md)
- leases, [Process Pauses](ch08.md)
  
  - implementation with ZooKeeper, [Membership and Coordination Services](ch09.md)
  - need for fencing, [The leader and the lock](ch08.md)
- ledgers, [Advantages of immutable events](ch11.md)
  
  - distributed ledger technologies, [Tools for auditable data systems](ch12.md)
- legacy systems, maintenance of, [Maintainability](ch01.md)
- less (Unix tool), [Transparency and experimentation](ch10.md)
- LevelDB (storage engine), [Making an LSM-tree out of SSTables](ch03.md)
- leveled compaction, [Performance optimizations](ch03.md)
- Levenshtein automata, [Full-text search and fuzzy indexes](ch03.md)
- limping (partial failure), [Summary](ch08.md)
- linearizability, [Linearizability](ch09.md)-[Linearizability and network delays](ch09.md), [Glossary](glossary01.md)
  
  - cost of, [The Cost of Linearizability](ch09.md)-[Linearizability and network delays](ch09.md)
    
    - CAP theorem, [The CAP theorem](ch09.md)
    - memory on multi-core CPUs, [Linearizability and network delays](ch09.md)
  - definition, [What Makes a System Linearizable?](ch09.md)-[What Makes a System Linearizable?](ch09.md)
  - implementing with total order broadcast, [Implementing linearizable storage using total order broadcast](ch09.md)
  - in ZooKeeper, [Membership and Coordination Services](ch09.md)
  - of derived data systems, [Derived data versus distributed transactions](ch12.md), [Timeliness and Integrity](ch12.md)
    
    - avoiding coordination, [Coordination-avoiding data systems](ch12.md)
  - of different replication methods, [Implementing Linearizable Systems](ch09.md)-[Linearizability and quorums](ch09.md)
    
    - using quorums, [Linearizability and quorums](ch09.md)
  - relying on, [Relying on Linearizability](ch09.md)-[Cross-channel timing dependencies](ch09.md)
    
    - constraints and uniqueness, [Constraints and uniqueness guarantees](ch09.md)
    - cross-channel timing dependencies, [Cross-channel timing dependencies](ch09.md)
    - locking and leader election, [Locking and leader election](ch09.md)
  - stronger than causal consistency, [Linearizability is stronger than causal consistency](ch09.md)
  - using to implement total order broadcast, [Implementing total order broadcast using linearizable storage](ch09.md)
  - versus serializability, [What Makes a System Linearizable?](ch09.md)
- LinkedIn
  
  - Azkaban (workflow scheduler), [MapReduce workflows](ch10.md)
  - Databus (change data capture), [Trigger-based replication](ch05.md), [Implementing change data capture](ch11.md)
  - Espresso (database), [The Object-Relational Mismatch](ch02.md), [But what is the writer’s schema?](ch04.md), [Different values written at different times](ch04.md), [Leaders and Followers](ch05.md), [Request Routing](ch06.md)
  - Helix (cluster manager) (see Helix)
  - profile (example), [The Object-Relational Mismatch](ch02.md)
  - reference to company entity (example), [Many-to-One and Many-to-Many Relationships](ch02.md)
  - Rest.li (RPC framework), [Current directions for RPC](ch04.md)
  - Voldemort (database) (see Voldemort)
- Linux, leap second bug, [Software Errors](ch01.md), [Clock Synchronization and Accuracy](ch08.md)
- liveness properties, [Safety and liveness](ch08.md)
- LMDB (storage engine), [B-tree optimizations](ch03.md), [Indexes and snapshot isolation](ch07.md)
- load
  
  - approaches to coping with, [Approaches for Coping with Load](ch01.md)
  - describing, [Describing Load](ch01.md)
  - load testing, [Describing Performance](ch01.md)
- load balancing (messaging), [Multiple consumers](ch11.md)
- local indexes (see document-partitioned indexes)
- locality (data access), [The Object-Relational Mismatch](ch02.md), [Data locality for queries](ch02.md), [Glossary](glossary01.md)
  
  - in batch processing, [Distributed execution of MapReduce](ch10.md), [Example: analysis of user activity events](ch10.md), [Dataflow engines](ch10.md)
  - in stateful clients, [Clients with offline operation](ch05.md), [Stateful, offline-capable clients](ch12.md)
  - in stream processing, [Stream-table join (stream enrichment)](ch11.md), [Rebuilding state after a failure](ch11.md), [Stream processors and services](ch12.md), [Uniqueness in log-based messaging](ch12.md)
- location transparency, [The problems with remote procedure calls (RPCs)](ch04.md)
  
  - in the actor model, [Distributed actor frameworks](ch04.md)
- locks, [Glossary](glossary01.md)
  
  - deadlock, [Implementation of two-phase locking](ch07.md)
  - distributed locking, [The leader and the lock](ch08.md)-[Fencing tokens](ch08.md), [Locking and leader election](ch09.md)
    
    - fencing tokens, [Fencing tokens](ch08.md)
    - implementation with ZooKeeper, [Membership and Coordination Services](ch09.md)
    - relation to consensus, [Summary](ch09.md)
  - for transaction isolation
    
    - in snapshot isolation, [Implementing snapshot isolation](ch07.md)
    - in two-phase locking (2PL), [Two-Phase Locking (2PL)](ch07.md)-[Index-range locks](ch07.md)
    - making operations atomic, [Atomic write operations](ch07.md)
    - performance, [Performance of two-phase locking](ch07.md)
    - preventing dirty writes, [Implementing read committed](ch07.md)
    - preventing phantoms with index-range locks, [Index-range locks](ch07.md), [Detecting writes that affect prior reads](ch07.md)
    - read locks (shared mode), [Implementing read committed](ch07.md), [Implementation of two-phase locking](ch07.md)
    - shared mode and exclusive mode, [Implementation of two-phase locking](ch07.md)
  - in two-phase commit (2PC)
    
    - deadlock detection, [Limitations of distributed transactions](ch09.md)
    - in-doubt transactions holding locks, [Holding locks while in doubt](ch09.md)
  - materializing conflicts with, [Materializing conflicts](ch07.md)
  - preventing lost updates by explicit locking, [Explicit locking](ch07.md)
- log sequence number, [Setting Up New Followers](ch05.md), [Consumer offsets](ch11.md)
- logic programming languages, [Designing Applications Around Dataflow](ch12.md)
- logical clocks, [Timestamps for ordering events](ch08.md), [Sequence Number Ordering](ch09.md), [Ordering events to capture causality](ch12.md)
  
  - for read-after-write consistency, [Reading Your Own Writes](ch05.md)
- logical logs, [Logical (row-based) log replication](ch05.md)
- logs (data structure), [Data Structures That Power Your Database](ch03.md), [Glossary](glossary01.md)
  
  - advantages of immutability, [Advantages of immutable events](ch11.md)
  - compaction, [Hash Indexes](ch03.md), [Performance optimizations](ch03.md), [Log compaction](ch11.md), [State, Streams, and Immutability](ch11.md)
    
    - for stream operator state, [Rebuilding state after a failure](ch11.md)
  - creating using total order broadcast, [Using total order broadcast](ch09.md)
  - implementing uniqueness constraints, [Uniqueness in log-based messaging](ch12.md)
  - log-based messaging, [Partitioned Logs](ch11.md)-[Replaying old messages](ch11.md)
    
    - comparison to traditional messaging, [Logs compared to traditional messaging](ch11.md), [Replaying old messages](ch11.md)
    - consumer offsets, [Consumer offsets](ch11.md)
    - disk space usage, [Disk space usage](ch11.md)
    - replaying old messages, [Replaying old messages](ch11.md), [Reprocessing data for application evolution](ch12.md), [Unifying batch and stream processing](ch12.md)
    - slow consumers, [When consumers cannot keep up with producers](ch11.md)
    - using logs for message storage, [Using logs for message storage](ch11.md)
  - log-structured storage, [Data Structures That Power Your Database](ch03.md)-[Performance optimizations](ch03.md)
    
    - log-structured merge tree (see LSM-trees)
  - replication, [Leaders and Followers](ch05.md), [Implementation of Replication Logs](ch05.md)-[Trigger-based replication](ch05.md)
    
    - change data capture, [Change Data Capture](ch11.md)-[API support for change streams](ch11.md)
      
      - (see also changelogs)
    - coordination with snapshot, [Setting Up New Followers](ch05.md)
    - logical (row-based) replication, [Logical (row-based) log replication](ch05.md)
    - statement-based replication, [Statement-based replication](ch05.md)
    - trigger-based replication, [Trigger-based replication](ch05.md)
    - write-ahead log (WAL) shipping, [Write-ahead log (WAL) shipping](ch05.md)
  - scalability limits, [The limits of total ordering](ch12.md)
- loose coupling, [Separation of logic and wiring](ch10.md), [Materialization of Intermediate State](ch10.md), [Making unbundling work](ch12.md)
- lost updates (see updates)
- LSM-trees (indexes), [Making an LSM-tree out of SSTables](ch03.md)-[Performance optimizations](ch03.md)
  
  - comparison to B-trees, [Comparing B-Trees and LSM-Trees](ch03.md)-[Downsides of LSM-trees](ch03.md)
- Lucene (storage engine), [Making an LSM-tree out of SSTables](ch03.md)
  
  - building indexes in batch processes, [Building search indexes](ch10.md)
  - similarity search, [Full-text search and fuzzy indexes](ch03.md)
- Luigi (workflow scheduler), [MapReduce workflows](ch10.md)
- LWW (see last write wins)

### M

- machine learning
  
  - ethical considerations, [Bias and discrimination](ch12.md)
    
    - (see also ethics)
  - iterative processing, [Graphs and Iterative Processing](ch10.md)
  - models derived from training data, [Application code as a derivation function](ch12.md)
  - statistical and numerical algorithms, [Specialization for different domains](ch10.md)
- MADlib (machine learning toolkit), [Specialization for different domains](ch10.md)
- magic scaling sauce, [Approaches for Coping with Load](ch01.md)
- Mahout (machine learning toolkit), [Specialization for different domains](ch10.md)
- maintainability, [Maintainability](ch01.md)-[Evolvability: Making Change Easy](ch01.md), [The Future of Data Systems](ch12.md)
  
  - defined, [Summary](ch01.md)
  - design principles for software systems, [Maintainability](ch01.md)
  - evolvability (see evolvability)
  - operability, [Operability: Making Life Easy for Operations](ch01.md)
  - simplicity and managing complexity, [Simplicity: Managing Complexity](ch01.md)
- many-to-many relationships
  
  - in document model versus relational model, [Which data model leads to simpler application code?](ch02.md)
  - modeling as graphs, [Graph-Like Data Models](ch02.md)
- many-to-one and many-to-many relationships, [Many-to-One and Many-to-Many Relationships](ch02.md)-[Many-to-One and Many-to-Many Relationships](ch02.md)
- many-to-one relationships, [Many-to-One and Many-to-Many Relationships](ch02.md)
- MapReduce (batch processing), [Batch Processing](ch10.md), [MapReduce Job Execution](ch10.md)-[MapReduce Job Execution](ch10.md)
  
  - accessing external services within job, [Example: analysis of user activity events](ch10.md), [Key-value stores as batch process output](ch10.md)
  - comparison to distributed databases
    
    - designing for frequent faults, [Designing for frequent faults](ch10.md)
    - diversity of processing models, [Diversity of processing models](ch10.md)
    - diversity of storage, [Diversity of storage](ch10.md)
  - comparison to stream processing, [Processing Streams](ch11.md)
  - comparison to Unix, [Philosophy of batch process outputs](ch10.md)-[Philosophy of batch process outputs](ch10.md)
  - disadvantages and limitations of, [Beyond MapReduce](ch10.md)
  - fault tolerance, [Bringing related data together in the same place](ch10.md), [Philosophy of batch process outputs](ch10.md), [Fault tolerance](ch10.md)
  - higher-level tools, [MapReduce workflows](ch10.md), [High-Level APIs and Languages](ch10.md)
  - implementation in Hadoop, [Distributed execution of MapReduce](ch10.md)-[MapReduce workflows](ch10.md)
    
    - the shuffle, [Distributed execution of MapReduce](ch10.md)
  - implementation in MongoDB, [MapReduce Querying](ch02.md)-[MapReduce Querying](ch02.md)
  - machine learning, [Specialization for different domains](ch10.md)
  - map-side processing, [Map-Side Joins](ch10.md)-[MapReduce workflows with map-side joins](ch10.md)
    
    - broadcast hash joins, [Broadcast hash joins](ch10.md)
    - merge joins, [Map-side merge joins](ch10.md)
    - partitioned hash joins, [Partitioned hash joins](ch10.md)
  - mapper and reducer functions, [MapReduce Job Execution](ch10.md)
  - materialization of intermediate state, [Materialization of Intermediate State](ch10.md)-[Discussion of materialization](ch10.md)
  - output of batch workflows, [The Output of Batch Workflows](ch10.md)-[Key-value stores as batch process output](ch10.md)
    
    - building search indexes, [Building search indexes](ch10.md)
    - key-value stores, [Key-value stores as batch process output](ch10.md)
  - reduce-side processing, [Reduce-Side Joins and Grouping](ch10.md)-[Handling skew](ch10.md)
    
    - analysis of user activity events (example), [Example: analysis of user activity events](ch10.md)
    - grouping records by same key, [GROUP BY](ch10.md)
    - handling skew, [Handling skew](ch10.md)
    - sort-merge joins, [Sort-merge joins](ch10.md)
  - workflows, [MapReduce workflows](ch10.md)
- marshalling (see encoding)
- massively parallel processing (MPP), [Parallel Query Execution](ch06.md)
  
  - comparison to composing storage technologies, [Unbundled versus integrated systems](ch12.md)
  - comparison to Hadoop, [Comparing Hadoop to Distributed Databases](ch10.md)-[Designing for frequent faults](ch10.md), [The move toward declarative query languages](ch10.md)
- master-master replication (see multi-leader replication)
- master-slave replication (see leader-based replication)
- materialization, [Glossary](glossary01.md)
  
  - aggregate values, [Aggregation: Data Cubes and Materialized Views](ch03.md)
  - conflicts, [Materializing conflicts](ch07.md)
  - intermediate state (batch processing), [Materialization of Intermediate State](ch10.md)-[Discussion of materialization](ch10.md)
  - materialized views, [Aggregation: Data Cubes and Materialized Views](ch03.md)
    
    - as derived data, [Derived Data](part03.md), [Composing Data Storage Technologies](ch12.md)-[What’s missing?](ch12.md)
    - maintaining, using stream processing, [Maintaining materialized views](ch11.md), [Table-table join (materialized view maintenance)](ch11.md)
- Maven (Java build tool), [The move toward declarative query languages](ch10.md)
- Maxwell (change data capture), [Implementing change data capture](ch11.md)
- mean, [Describing Performance](ch01.md)
- media monitoring, [Search on streams](ch11.md)
- median, [Describing Performance](ch01.md)
- meeting room booking (example), [More examples of write skew](ch07.md), [Predicate locks](ch07.md), [Enforcing Constraints](ch12.md)
- membership services, [Membership services](ch09.md)
- Memcached (caching server), [Thinking About Data Systems](ch01.md), [Keeping everything in memory](ch03.md)
- memory
  
  - in-memory databases, [Keeping everything in memory](ch03.md)
    
    - durability, [Durability](ch07.md)
    - serial transaction execution, [Actual Serial Execution](ch07.md)
  - in-memory representation of data, [Formats for Encoding Data](ch04.md)
  - random bit-flips in, [Trust, but Verify](ch12.md)
  - use by indexes, [Hash Indexes](ch03.md), [SSTables and LSM-Trees](ch03.md)
- memory barrier (CPU instruction), [Linearizability and network delays](ch09.md)
- MemSQL (database)
  
  - in-memory storage, [Keeping everything in memory](ch03.md)
  - read committed isolation, [Implementing read committed](ch07.md)
- memtable (in LSM-trees), [Constructing and maintaining SSTables](ch03.md)
- Mercurial (version control system), [Limitations of immutability](ch11.md)
- merge joins, MapReduce map-side, [Map-side merge joins](ch10.md)
- mergeable persistent data structures, [Custom conflict resolution logic](ch05.md)
- merging sorted files, [SSTables and LSM-Trees](ch03.md), [Distributed execution of MapReduce](ch10.md), [Sort-merge joins](ch10.md)
- Merkle trees, [Tools for auditable data systems](ch12.md)
- Mesos (cluster manager), [Designing for frequent faults](ch10.md), [Separation of application code and state](ch12.md)
- message brokers (see messaging systems)
- message-passing, [Message-Passing Dataflow](ch04.md)-[Distributed actor frameworks](ch04.md)
  
  - advantages over direct RPC, [Message-Passing Dataflow](ch04.md)
  - distributed actor frameworks, [Distributed actor frameworks](ch04.md)
  - evolvability, [Distributed actor frameworks](ch04.md)
- MessagePack (encoding format), [Binary encoding](ch04.md)
- messages
  
  - exactly-once semantics, [Exactly-once message processing](ch09.md), [Fault Tolerance](ch11.md)
  - loss of, [Messaging Systems](ch11.md)
  - using total order broadcast, [Total Order Broadcast](ch09.md)
- messaging systems, [Stream Processing](ch11.md)-[Replaying old messages](ch11.md)
  
  - (see also streams)
  - backpressure, buffering, or dropping messages, [Messaging Systems](ch11.md)
  - brokerless messaging, [Direct messaging from producers to consumers](ch11.md)
  - event logs, [Partitioned Logs](ch11.md)-[Replaying old messages](ch11.md)
    
    - comparison to traditional messaging, [Logs compared to traditional messaging](ch11.md), [Replaying old messages](ch11.md)
    - consumer offsets, [Consumer offsets](ch11.md)
    - replaying old messages, [Replaying old messages](ch11.md), [Reprocessing data for application evolution](ch12.md), [Unifying batch and stream processing](ch12.md)
    - slow consumers, [When consumers cannot keep up with producers](ch11.md)
  - message brokers, [Message brokers](ch11.md)-[Acknowledgments and redelivery](ch11.md)
    
    - acknowledgements and redelivery, [Acknowledgments and redelivery](ch11.md)
    - comparison to event logs, [Logs compared to traditional messaging](ch11.md), [Replaying old messages](ch11.md)
    - multiple consumers of same topic, [Multiple consumers](ch11.md)
  - reliability, [Messaging Systems](ch11.md)
  - uniqueness in log-based messaging, [Uniqueness in log-based messaging](ch12.md)
- Meteor (web framework), [API support for change streams](ch11.md)
- microbatching, [Microbatching and checkpointing](ch11.md), [Batch and Stream Processing](ch12.md)
- microservices, [Dataflow Through Services: REST and RPC](ch04.md)
  
  - (see also services)
  - causal dependencies across services, [The limits of total ordering](ch12.md)
  - loose coupling, [Making unbundling work](ch12.md)
  - relation to batch/stream processors, [Batch Processing](ch10.md), [Stream processors and services](ch12.md)
- Microsoft
  
  - Azure Service Bus (messaging), [Message brokers compared to databases](ch11.md)
  - Azure Storage, [Synchronous Versus Asynchronous Replication](ch05.md), [MapReduce and Distributed Filesystems](ch10.md)
  - Azure Stream Analytics, [Stream analytics](ch11.md)
  - DCOM (Distributed Component Object Model), [The problems with remote procedure calls (RPCs)](ch04.md)
  - MSDTC (transaction coordinator), [Introduction to two-phase commit](ch09.md)
  - Orleans (see Orleans)
  - SQL Server (see SQL Server)
- migrating (rewriting) data, [Schema flexibility in the document model](ch02.md), [Different values written at different times](ch04.md), [Deriving several views from the same event log](ch11.md), [Reprocessing data for application evolution](ch12.md)
- modulus operator (%), [How not to do it: hash mod N](ch06.md)
- MongoDB (database)
  
  - aggregation pipeline, [MapReduce Querying](ch02.md)
  - atomic operations, [Atomic write operations](ch07.md)
  - BSON, [Data locality for queries](ch02.md)
  - document data model, [The Object-Relational Mismatch](ch02.md)
  - hash partitioning (sharding), [Partitioning by Hash of Key](ch06.md)-[Partitioning by Hash of Key](ch06.md)
  - key-range partitioning, [Partitioning by Key Range](ch06.md)
  - lack of join support, [Many-to-One and Many-to-Many Relationships](ch02.md), [Convergence of document and relational databases](ch02.md)
  - leader-based replication, [Leaders and Followers](ch05.md)
  - MapReduce support, [MapReduce Querying](ch02.md), [Distributed execution of MapReduce](ch10.md)
  - oplog parsing, [Implementing change data capture](ch11.md), [API support for change streams](ch11.md)
  - partition splitting, [Dynamic partitioning](ch06.md)
  - request routing, [Request Routing](ch06.md)
  - secondary indexes, [Partitioning Secondary Indexes by Document](ch06.md)
- Mongoriver (change data capture), [Implementing change data capture](ch11.md)
- monitoring, [Human Errors](ch01.md), [Operability: Making Life Easy for Operations](ch01.md)
- monotonic clocks, [Monotonic clocks](ch08.md)
- monotonic reads, [Monotonic Reads](ch05.md)
- MPP (see massively parallel processing)
- MSMQ (messaging), [XA transactions](ch09.md)
- multi-column indexes, [Multi-column indexes](ch03.md)
- multi-leader replication, [Multi-Leader Replication](ch05.md)-[Multi-Leader Replication Topologies](ch05.md)
  
  - (see also replication)
  - handling write conflicts, [Handling Write Conflicts](ch05.md)
    
    - conflict avoidance, [Conflict avoidance](ch05.md)
    - converging toward a consistent state, [Converging toward a consistent state](ch05.md)
    - custom conflict resolution logic, [Custom conflict resolution logic](ch05.md)
    - determining what is a conflict, [What is a conflict?](ch05.md)
  - linearizability, lack of, [Implementing Linearizable Systems](ch09.md)
  - replication topologies, [Multi-Leader Replication Topologies](ch05.md)-[Multi-Leader Replication Topologies](ch05.md)
  - use cases, [Use Cases for Multi-Leader Replication](ch05.md)
    
    - clients with offline operation, [Clients with offline operation](ch05.md)
    - collaborative editing, [Collaborative editing](ch05.md)
    - multi-datacenter replication, [Multi-datacenter operation](ch05.md), [The Cost of Linearizability](ch09.md)
- multi-object transactions, [Single-Object and Multi-Object Operations](ch07.md)
  
  - need for, [The need for multi-object transactions](ch07.md)
- Multi-Paxos (total order broadcast), [Consensus algorithms and total order broadcast](ch09.md)
- multi-table index cluster tables (Oracle), [Data locality for queries](ch02.md)
- multi-tenancy, [Network congestion and queueing](ch08.md)
- multi-version concurrency control (MVCC), [Implementing snapshot isolation](ch07.md), [Summary](ch07.md)
  
  - detecting stale MVCC reads, [Detecting stale MVCC reads](ch07.md)
  - indexes and snapshot isolation, [Indexes and snapshot isolation](ch07.md)
- mutual exclusion, [Pessimistic versus optimistic concurrency control](ch07.md)
  
  - (see also locks)
- MySQL (database)
  
  - binlog coordinates, [Setting Up New Followers](ch05.md)
  - binlog parsing for change data capture, [Implementing change data capture](ch11.md)
  - circular replication topology, [Multi-Leader Replication Topologies](ch05.md)
  - consistent snapshots, [Setting Up New Followers](ch05.md)
  - distributed transaction support, [XA transactions](ch09.md)
  - InnoDB storage engine (see InnoDB)
  - JSON support, [The Object-Relational Mismatch](ch02.md), [Convergence of document and relational databases](ch02.md)
  - leader-based replication, [Leaders and Followers](ch05.md)
  - performance of XA transactions, [Distributed Transactions in Practice](ch09.md)
  - row-based replication, [Logical (row-based) log replication](ch05.md)
  - schema changes in, [Schema flexibility in the document model](ch02.md)
  - snapshot isolation support, [Repeatable read and naming confusion](ch07.md)
    
    - (see also InnoDB)
  - statement-based replication, [Statement-based replication](ch05.md)
  - Tungsten Replicator (multi-leader replication), [Multi-datacenter operation](ch05.md)
    
    - conflict detection, [Multi-Leader Replication Topologies](ch05.md)

### N

- nanomsg (messaging library), [Direct messaging from producers to consumers](ch11.md)
- Narayana (transaction coordinator), [Introduction to two-phase commit](ch09.md)
- NATS (messaging), [Message brokers](ch04.md)
- near-real-time (nearline) processing, [Batch Processing](ch10.md)
  
  - (see also stream processing)
- Neo4j (database)
  
  - Cypher query language, [The Cypher Query Language](ch02.md)
  - graph data model, [Graph-Like Data Models](ch02.md)
- Nephele (dataflow engine), [Dataflow engines](ch10.md)
- netcat (Unix tool), [Separation of logic and wiring](ch10.md)
- Netflix Chaos Monkey, [Reliability](ch01.md), [Network Faults in Practice](ch08.md)
- Network Attached Storage (NAS), [Distributed Data](part02.md), [MapReduce and Distributed Filesystems](ch10.md)
- network model, [The network model](ch02.md)
  
  - graph databases versus, [The SPARQL query language](ch02.md)
  - imperative query APIs, [Declarative Queries on the Web](ch02.md)
- Network Time Protocol (see NTP)
- networks
  
  - congestion and queueing, [Network congestion and queueing](ch08.md)
  - datacenter network topologies, [Cloud Computing and Supercomputing](ch08.md)
  - faults (see faults)
  - linearizability and network delays, [Linearizability and network delays](ch09.md)
  - network partitions, [Network Faults in Practice](ch08.md), [The CAP theorem](ch09.md)
  - timeouts and unbounded delays, [Timeouts and Unbounded Delays](ch08.md)
- next-key locking, [Index-range locks](ch07.md)
- nodes (in graphs) (see vertices)
- nodes (processes), [Glossary](glossary01.md)
  
  - handling outages in leader-based replication, [Handling Node Outages](ch05.md)
  - system models for failure, [System Model and Reality](ch08.md)
- noisy neighbors, [Network congestion and queueing](ch08.md)
- nonblocking atomic commit, [Three-phase commit](ch09.md)
- nondeterministic operations
  
  - accidental nondeterminism, [Fault tolerance](ch10.md)
  - partial failures in distributed systems, [Faults and Partial Failures](ch08.md)
- nonfunctional requirements, [Summary](ch01.md)
- nonrepeatable reads, [Snapshot Isolation and Repeatable Read](ch07.md)
  
  - (see also read skew)
- normalization (data representation), [Many-to-One and Many-to-Many Relationships](ch02.md), [Glossary](glossary01.md)
  
  - executing joins, [Which data model leads to simpler application code?](ch02.md), [Convergence of document and relational databases](ch02.md), [Reduce-Side Joins and Grouping](ch10.md)
  - foreign key references, [The need for multi-object transactions](ch07.md)
  - in systems of record, [Derived Data](part03.md)
  - versus denormalization, [Deriving several views from the same event log](ch11.md)
- NoSQL, [The Birth of NoSQL](ch02.md), [Unbundling Databases](ch12.md)
  
  - transactions and, [The Slippery Concept of a Transaction](ch07.md)
- Notation3 (N3), [Triple-Stores and SPARQL](ch02.md)
- npm (package manager), [The move toward declarative query languages](ch10.md)
- NTP (Network Time Protocol), [Unreliable Clocks](ch08.md)
  
  - accuracy, [Clock Synchronization and Accuracy](ch08.md), [Timestamps for ordering events](ch08.md)
  - adjustments to monotonic clocks, [Monotonic clocks](ch08.md)
  - multiple server addresses, [Weak forms of lying](ch08.md)
- numbers, in XML and JSON encodings, [JSON, XML, and Binary Variants](ch04.md)

### O

- object-relational mapping (ORM) frameworks, [The Object-Relational Mismatch](ch02.md)
  
  - error handling and aborted transactions, [Handling errors and aborts](ch07.md)
  - unsafe read-modify-write cycle code, [Atomic write operations](ch07.md)
- object-relational mismatch, [The Object-Relational Mismatch](ch02.md)
- observer pattern, [Separation of application code and state](ch12.md)
- offline systems, [Batch Processing](ch10.md)
  
  - (see also batch processing)
  - stateful, offline-capable clients, [Clients with offline operation](ch05.md), [Stateful, offline-capable clients](ch12.md)
- offline-first applications, [Stateful, offline-capable clients](ch12.md)
- offsets
  
  - consumer offsets in partitioned logs, [Consumer offsets](ch11.md)
  - messages in partitioned logs, [Using logs for message storage](ch11.md)
- OLAP (online analytic processing), [Transaction Processing or Analytics?](ch03.md), [Glossary](glossary01.md)
  
  - data cubes, [Aggregation: Data Cubes and Materialized Views](ch03.md)
- OLTP (online transaction processing), [Transaction Processing or Analytics?](ch03.md), [Glossary](glossary01.md)
  
  - analytics queries versus, [The Output of Batch Workflows](ch10.md)
  - workload characteristics, [Actual Serial Execution](ch07.md)
- one-to-many relationships, [The Object-Relational Mismatch](ch02.md)
  
  - JSON representation, [The Object-Relational Mismatch](ch02.md)
- online systems, [Batch Processing](ch10.md)
  
  - (see also services)
- Oozie (workflow scheduler), [MapReduce workflows](ch10.md)
- OpenAPI (service definition format), [Web services](ch04.md)
- OpenStack
  
  - Nova (cloud infrastructure)
    
    - use of ZooKeeper, [Membership and Coordination Services](ch09.md)
  - Swift (object storage), [MapReduce and Distributed Filesystems](ch10.md)
- operability, [Operability: Making Life Easy for Operations](ch01.md)
- operating systems versus databases, [Unbundling Databases](ch12.md)
- operation identifiers, [Operation identifiers](ch12.md), [Multi-partition request processing](ch12.md)
- operational transformation, [Custom conflict resolution logic](ch05.md)
- operators, [Dataflow engines](ch10.md)
  
  - flow of data between, [Graphs and Iterative Processing](ch10.md)
  - in stream processing, [Processing Streams](ch11.md)
- optimistic concurrency control, [Pessimistic versus optimistic concurrency control](ch07.md)
- Oracle (database)
  
  - distributed transaction support, [XA transactions](ch09.md)
  - GoldenGate (change data capture), [Trigger-based replication](ch05.md), [Multi-datacenter operation](ch05.md), [Implementing change data capture](ch11.md)
  - lack of serializability, [Isolation](ch07.md)
  - leader-based replication, [Leaders and Followers](ch05.md)
  - multi-table index cluster tables, [Data locality for queries](ch02.md)
  - not preventing write skew, [Characterizing write skew](ch07.md)
  - partitioned indexes, [Partitioning Secondary Indexes by Term](ch06.md)
  - PL/SQL language, [Pros and cons of stored procedures](ch07.md)
  - preventing lost updates, [Automatically detecting lost updates](ch07.md)
  - read committed isolation, [Implementing read committed](ch07.md)
  - Real Application Clusters (RAC), [Locking and leader election](ch09.md)
  - recursive query support, [Graph Queries in SQL](ch02.md)
  - snapshot isolation support, [Snapshot Isolation and Repeatable Read](ch07.md), [Repeatable read and naming confusion](ch07.md)
  - TimesTen (in-memory database), [Keeping everything in memory](ch03.md)
  - WAL-based replication, [Write-ahead log (WAL) shipping](ch05.md)
  - XML support, [The Object-Relational Mismatch](ch02.md)
- ordering, [Ordering Guarantees](ch09.md)-[Implementing total order broadcast using linearizable storage](ch09.md)
  
  - by sequence numbers, [Sequence Number Ordering](ch09.md)-[Timestamp ordering is not sufficient](ch09.md)
  - causal ordering, [Ordering and Causality](ch09.md)-[Capturing causal dependencies](ch09.md)
    
    - partial order, [The causal order is not a total order](ch09.md)
  - limits of total ordering, [The limits of total ordering](ch12.md)
  - total order broadcast, [Total Order Broadcast](ch09.md)-[Implementing total order broadcast using linearizable storage](ch09.md)
- Orleans (actor framework), [Distributed actor frameworks](ch04.md)
- outliers (response time), [Describing Performance](ch01.md)
- Oz (programming language), [Designing Applications Around Dataflow](ch12.md)

### P

- package managers, [The move toward declarative query languages](ch10.md), [Separation of application code and state](ch12.md)
- packet switching, [Can we not simply make network delays predictable?](ch08.md)
- packets
  
  - corruption of, [Weak forms of lying](ch08.md)
  - sending via UDP, [Direct messaging from producers to consumers](ch11.md)
- PageRank (algorithm), [Graph-Like Data Models](ch02.md), [Graphs and Iterative Processing](ch10.md)
- paging (see virtual memory)
- ParAccel (database), [The divergence between OLTP databases and data warehouses](ch03.md)
- parallel databases (see massively parallel processing)
- parallel execution
  
  - of graph analysis algorithms, [Parallel execution](ch10.md)
  - queries in MPP databases, [Parallel Query Execution](ch06.md)
- Parquet (data format), [Column-Oriented Storage](ch03.md), [Archival storage](ch04.md)
  
  - (see also column-oriented storage)
  - use in Hadoop, [Philosophy of batch process outputs](ch10.md)
- partial failures, [Faults and Partial Failures](ch08.md), [Summary](ch08.md)
  
  - limping, [Summary](ch08.md)
- partial order, [The causal order is not a total order](ch09.md)
- partitioning, [Partitioning](ch06.md)-[Summary](ch06.md), [Glossary](glossary01.md)
  
  - and replication, [Partitioning and Replication](ch06.md)
  - in batch processing, [Summary](ch10.md)
  - multi-partition operations, [Multi-partition data processing](ch12.md)
    
    - enforcing constraints, [Multi-partition request processing](ch12.md)
    - secondary index maintenance, [Maintaining derived state](ch12.md)
  - of key-value data, [Partitioning of Key-Value Data](ch06.md)-[Skewed Workloads and Relieving Hot Spots](ch06.md)
    
    - by key range, [Partitioning by Key Range](ch06.md)
    - skew and hot spots, [Skewed Workloads and Relieving Hot Spots](ch06.md)
  - rebalancing partitions, [Rebalancing Partitions](ch06.md)-[Operations: Automatic or Manual Rebalancing](ch06.md)
    
    - automatic or manual rebalancing, [Operations: Automatic or Manual Rebalancing](ch06.md)
    - problems with hash mod N, [How not to do it: hash mod N](ch06.md)
    - using dynamic partitioning, [Dynamic partitioning](ch06.md)
    - using fixed number of partitions, [Fixed number of partitions](ch06.md)
    - using N partitions per node, [Partitioning proportionally to nodes](ch06.md)
  - replication and, [Distributed Data](part02.md)
  - request routing, [Request Routing](ch06.md)-[Parallel Query Execution](ch06.md)
  - secondary indexes, [Partitioning and Secondary Indexes](ch06.md)-[Partitioning Secondary Indexes by Term](ch06.md)
    
    - document-based partitioning, [Partitioning Secondary Indexes by Document](ch06.md)
    - term-based partitioning, [Partitioning Secondary Indexes by Term](ch06.md)
  - serial execution of transactions and, [Partitioning](ch07.md)
- Paxos (consensus algorithm), [Consensus algorithms and total order broadcast](ch09.md)
  
  - ballot number, [Epoch numbering and quorums](ch09.md)
  - Multi-Paxos (total order broadcast), [Consensus algorithms and total order broadcast](ch09.md)
- percentiles, [Describing Performance](ch01.md), [Glossary](glossary01.md)
  
  - calculating efficiently, [Describing Performance](ch01.md)
  - importance of high percentiles, [Describing Performance](ch01.md)
  - use in service level agreements (SLAs), [Describing Performance](ch01.md)
- Percona XtraBackup (MySQL tool), [Setting Up New Followers](ch05.md)
- performance
  
  - describing, [Describing Performance](ch01.md)
  - of distributed transactions, [Distributed Transactions in Practice](ch09.md)
  - of in-memory databases, [Keeping everything in memory](ch03.md)
  - of linearizability, [Linearizability and network delays](ch09.md)
  - of multi-leader replication, [Multi-datacenter operation](ch05.md)
- perpetual inconsistency, [Timeliness and Integrity](ch12.md)
- pessimistic concurrency control, [Pessimistic versus optimistic concurrency control](ch07.md)
- phantoms (transaction isolation), [Phantoms causing write skew](ch07.md)
  
  - materializing conflicts, [Materializing conflicts](ch07.md)
  - preventing, in serializability, [Predicate locks](ch07.md)
- physical clocks (see clocks)
- pickle (Python), [Language-Specific Formats](ch04.md)
- Pig (dataflow language), [Beyond MapReduce](ch10.md), [High-Level APIs and Languages](ch10.md)
  
  - replicated joins, [Broadcast hash joins](ch10.md)
  - skewed joins, [Handling skew](ch10.md)
  - workflows, [MapReduce workflows](ch10.md)
- Pinball (workflow scheduler), [MapReduce workflows](ch10.md)
- pipelined execution, [Discussion of materialization](ch10.md)
  
  - in Unix, [The Unix Philosophy](ch10.md)
- point in time, [Unreliable Clocks](ch08.md)
- polyglot persistence, [The Birth of NoSQL](ch02.md)
- polystores, [The meta-database of everything](ch12.md)
- PostgreSQL (database)
  
  - BDR (multi-leader replication), [Multi-datacenter operation](ch05.md)
    
    - causal ordering of writes, [Multi-Leader Replication Topologies](ch05.md)
  - Bottled Water (change data capture), [Implementing change data capture](ch11.md)
  - Bucardo (trigger-based replication), [Trigger-based replication](ch05.md), [Custom conflict resolution logic](ch05.md)
  - distributed transaction support, [XA transactions](ch09.md)
  - foreign data wrappers, [The meta-database of everything](ch12.md)
  - full text search support, [Combining Specialized Tools by Deriving Data](ch12.md)
  - leader-based replication, [Leaders and Followers](ch05.md)
  - log sequence number, [Setting Up New Followers](ch05.md)
  - MVCC implementation, [Implementing snapshot isolation](ch07.md), [Indexes and snapshot isolation](ch07.md)
  - PL/pgSQL language, [Pros and cons of stored procedures](ch07.md)
  - PostGIS geospatial indexes, [Multi-column indexes](ch03.md)
  - preventing lost updates, [Automatically detecting lost updates](ch07.md)
  - preventing write skew, [Characterizing write skew](ch07.md), [Serializable Snapshot Isolation (SSI)](ch07.md)
  - read committed isolation, [Implementing read committed](ch07.md)
  - recursive query support, [Graph Queries in SQL](ch02.md)
  - representing graphs, [Property Graphs](ch02.md)
  - serializable snapshot isolation (SSI), [Serializable Snapshot Isolation (SSI)](ch07.md)
  - snapshot isolation support, [Snapshot Isolation and Repeatable Read](ch07.md), [Repeatable read and naming confusion](ch07.md)
  - WAL-based replication, [Write-ahead log (WAL) shipping](ch05.md)
  - XML and JSON support, [The Object-Relational Mismatch](ch02.md), [Convergence of document and relational databases](ch02.md)
- pre-splitting, [Dynamic partitioning](ch06.md)
- Precision Time Protocol (PTP), [Clock Synchronization and Accuracy](ch08.md)
- predicate locks, [Predicate locks](ch07.md)
- predictive analytics, [Predictive Analytics](ch12.md)-[Feedback loops](ch12.md)
  
  - amplifying bias, [Bias and discrimination](ch12.md)
  - ethics of (see ethics)
  - feedback loops, [Feedback loops](ch12.md)
- preemption
  
  - of datacenter resources, [Designing for frequent faults](ch10.md)
  - of threads, [Process Pauses](ch08.md)
- Pregel processing model, [The Pregel processing model](ch10.md)
- primary keys, [Other Indexing Structures](ch03.md), [Glossary](glossary01.md)
  
  - compound primary key (Cassandra), [Partitioning by Hash of Key](ch06.md)
- primary-secondary replication (see leader-based replication)
- privacy, [Privacy and Tracking](ch12.md)-[Legislation and self-regulation](ch12.md)
  
  - consent and freedom of choice, [Consent and freedom of choice](ch12.md)
  - data as assets and power, [Data as assets and power](ch12.md)
  - deleting data, [Limitations of immutability](ch11.md)
  - ethical considerations (see ethics)
  - legislation and self-regulation, [Legislation and self-regulation](ch12.md)
  - meaning of, [Privacy and use of data](ch12.md)
  - surveillance, [Surveillance](ch12.md)
  - tracking behavioral data, [Privacy and Tracking](ch12.md)
- probabilistic algorithms, [Describing Performance](ch01.md), [Stream analytics](ch11.md)
- process pauses, [Process Pauses](ch08.md)-[Limiting the impact of garbage collection](ch08.md)
- processing time (of events), [Reasoning About Time](ch11.md)
- producers (message streams), [Transmitting Event Streams](ch11.md)
- programming languages
  
  - dataflow languages, [Designing Applications Around Dataflow](ch12.md)
  - for stored procedures, [Pros and cons of stored procedures](ch07.md)
  - functional reactive programming (FRP), [Designing Applications Around Dataflow](ch12.md)
  - logic programming, [Designing Applications Around Dataflow](ch12.md)
- Prolog (language), [The Foundation: Datalog](ch02.md)
  
  - (see also Datalog)
- promises (asynchronous operations), [Current directions for RPC](ch04.md)
- property graphs, [Property Graphs](ch02.md)
  
  - Cypher query language, [The Cypher Query Language](ch02.md)
- Protocol Buffers (data format), [Thrift and Protocol Buffers](ch04.md)-[Datatypes and schema evolution](ch04.md)
  
  - field tags and schema evolution, [Field tags and schema evolution](ch04.md)
- provenance of data, [Designing for auditability](ch12.md)
- publish/subscribe model, [Messaging Systems](ch11.md)
- publishers (message streams), [Transmitting Event Streams](ch11.md)
- punch card tabulating machines, [Batch Processing](ch10.md)
- pure functions, [MapReduce Querying](ch02.md)
- putting computation near data, [Distributed execution of MapReduce](ch10.md)

### Q

- Qpid (messaging), [Message brokers compared to databases](ch11.md)
- quality of service (QoS), [Can we not simply make network delays predictable?](ch08.md)
- Quantcast File System (distributed filesystem), [MapReduce and Distributed Filesystems](ch10.md)
- query languages, [Query Languages for Data](ch02.md)-[MapReduce Querying](ch02.md)
  
  - aggregation pipeline, [MapReduce Querying](ch02.md)
  - CSS and XSL, [Declarative Queries on the Web](ch02.md)
  - Cypher, [The Cypher Query Language](ch02.md)
  - Datalog, [The Foundation: Datalog](ch02.md)
  - Juttle, [Designing Applications Around Dataflow](ch12.md)
  - MapReduce querying, [MapReduce Querying](ch02.md)-[MapReduce Querying](ch02.md)
  - recursive SQL queries, [Graph Queries in SQL](ch02.md)
  - relational algebra and SQL, [Query Languages for Data](ch02.md)
  - SPARQL, [The SPARQL query language](ch02.md)
- query optimizers, [The relational model](ch02.md), [The move toward declarative query languages](ch10.md)
- queueing delays (networks), [Network congestion and queueing](ch08.md)
  
  - head-of-line blocking, [Describing Performance](ch01.md)
  - latency and response time, [Describing Performance](ch01.md)
- queues (messaging), [Message brokers](ch04.md)
- quorums, [Quorums for reading and writing](ch05.md)-[Limitations of Quorum Consistency](ch05.md), [Glossary](glossary01.md)
  
  - for leaderless replication, [Quorums for reading and writing](ch05.md)
  - in consensus algorithms, [Epoch numbering and quorums](ch09.md)
  - limitations of consistency, [Limitations of Quorum Consistency](ch05.md)-[Monitoring staleness](ch05.md), [Linearizability and quorums](ch09.md)
  - making decisions in distributed systems, [The Truth Is Defined by the Majority](ch08.md)
  - monitoring staleness, [Monitoring staleness](ch05.md)
  - multi-datacenter replication, [Multi-datacenter operation](ch05.md)
  - relying on durability, [Mapping system models to the real world](ch08.md)
  - sloppy quorums and hinted handoff, [Sloppy Quorums and Hinted Handoff](ch05.md)

### R

- R-trees (indexes), [Multi-column indexes](ch03.md)
- RabbitMQ (messaging), [Message brokers](ch04.md), [Message brokers compared to databases](ch11.md)
  
  - leader-based replication, [Leaders and Followers](ch05.md)
- race conditions, [Isolation](ch07.md)
  
  - (see also concurrency)
  - avoiding with linearizability, [Cross-channel timing dependencies](ch09.md)
  - caused by dual writes, [Keeping Systems in Sync](ch11.md)
  - dirty writes, [No dirty writes](ch07.md)
  - in counter increments, [No dirty writes](ch07.md)
  - lost updates, [Preventing Lost Updates](ch07.md)-[Conflict resolution and replication](ch07.md)
  - preventing with event logs, [Concurrency control](ch11.md), [Dataflow: Interplay between state changes and application code](ch12.md)
  - preventing with serializable isolation, [Serializability](ch07.md)
  - write skew, [Write Skew and Phantoms](ch07.md)-[Materializing conflicts](ch07.md)
- Raft (consensus algorithm), [Consensus algorithms and total order broadcast](ch09.md)
  
  - sensitivity to network problems, [Limitations of consensus](ch09.md)
  - term number, [Epoch numbering and quorums](ch09.md)
  - use in etcd, [Distributed Transactions and Consensus](ch09.md)
- RAID (Redundant Array of Independent Disks), [Hardware Faults](ch01.md), [MapReduce and Distributed Filesystems](ch10.md)
- railways, schema migration on, [Reprocessing data for application evolution](ch12.md)
- RAMCloud (in-memory storage), [Keeping everything in memory](ch03.md)
- ranking algorithms, [Graphs and Iterative Processing](ch10.md)
- RDF (Resource Description Framework), [The semantic web](ch02.md)
  
  - querying with SPARQL, [The SPARQL query language](ch02.md)
- RDMA (Remote Direct Memory Access), [Cloud Computing and Supercomputing](ch08.md)
- read committed isolation level, [Read Committed](ch07.md)-[Implementing read committed](ch07.md)
  
  - implementing, [Implementing read committed](ch07.md)
  - multi-version concurrency control (MVCC), [Implementing snapshot isolation](ch07.md)
  - no dirty reads, [No dirty reads](ch07.md)
  - no dirty writes, [No dirty writes](ch07.md)
- read path (derived data), [Observing Derived State](ch12.md)
- read repair (leaderless replication), [Read repair and anti-entropy](ch05.md)
  
  - for linearizability, [Linearizability and quorums](ch09.md)
- read replicas (see leader-based replication)
- read skew (transaction isolation), [Snapshot Isolation and Repeatable Read](ch07.md), [Summary](ch07.md)
  
  - as violation of causality, [Ordering and Causality](ch09.md)
- read-after-write consistency, [Reading Your Own Writes](ch05.md), [Timeliness and Integrity](ch12.md)
  
  - cross-device, [Reading Your Own Writes](ch05.md)
- read-modify-write cycle, [Preventing Lost Updates](ch07.md)
- read-scaling architecture, [Problems with Replication Lag](ch05.md)
- reads as events, [Reads are events too](ch12.md)
- real-time
  
  - collaborative editing, [Collaborative editing](ch05.md)
  - near-real-time processing, [Batch Processing](ch10.md)
    
    - (see also stream processing)
  - publish/subscribe dataflow, [End-to-end event streams](ch12.md)
  - response time guarantees, [Response time guarantees](ch08.md)
  - time-of-day clocks, [Time-of-day clocks](ch08.md)
- rebalancing partitions, [Rebalancing Partitions](ch06.md)-[Operations: Automatic or Manual Rebalancing](ch06.md), [Glossary](glossary01.md)
  
  - (see also partitioning)
  - automatic or manual rebalancing, [Operations: Automatic or Manual Rebalancing](ch06.md)
  - dynamic partitioning, [Dynamic partitioning](ch06.md)
  - fixed number of partitions, [Fixed number of partitions](ch06.md)
  - fixed number of partitions per node, [Partitioning proportionally to nodes](ch06.md)
  - problems with hash mod N, [How not to do it: hash mod N](ch06.md)
- recency guarantee, [Linearizability](ch09.md)
- recommendation engines
  
  - batch process outputs, [Key-value stores as batch process output](ch10.md)
  - batch workflows, [MapReduce workflows](ch10.md), [Materialization of Intermediate State](ch10.md)
  - iterative processing, [Graphs and Iterative Processing](ch10.md)
  - statistical and numerical algorithms, [Specialization for different domains](ch10.md)
- records, [MapReduce Job Execution](ch10.md)
  
  - events in stream processing, [Transmitting Event Streams](ch11.md)
- recursive common table expressions (SQL), [Graph Queries in SQL](ch02.md)
- redelivery (messaging), [Acknowledgments and redelivery](ch11.md)
- Redis (database)
  
  - atomic operations, [Atomic write operations](ch07.md)
  - durability, [Keeping everything in memory](ch03.md)
  - Lua scripting, [Pros and cons of stored procedures](ch07.md)
  - single-threaded execution, [Actual Serial Execution](ch07.md)
  - usage example, [Thinking About Data Systems](ch01.md)
- redundancy
  
  - hardware components, [Hardware Faults](ch01.md)
  - of derived data, [Derived Data](part03.md)
    
    - (see also derived data)
- Reed–Solomon codes (error correction), [MapReduce and Distributed Filesystems](ch10.md)
- refactoring, [Evolvability: Making Change Easy](ch01.md)
  
  - (see also evolvability)
- regions (partitioning), [Partitioning](ch06.md)
- register (data structure), [What Makes a System Linearizable?](ch09.md)
- relational data model, [Relational Model Versus Document Model](ch02.md)-[Convergence of document and relational databases](ch02.md)
  
  - comparison to document model, [Relational Versus Document Databases Today](ch02.md)-[Convergence of document and relational databases](ch02.md)
  - graph queries in SQL, [Graph Queries in SQL](ch02.md)
  - in-memory databases with, [Keeping everything in memory](ch03.md)
  - many-to-one and many-to-many relationships, [Many-to-One and Many-to-Many Relationships](ch02.md)
  - multi-object transactions, need for, [The need for multi-object transactions](ch07.md)
  - NoSQL as alternative to, [The Birth of NoSQL](ch02.md)
  - object-relational mismatch, [The Object-Relational Mismatch](ch02.md)
  - relational algebra and SQL, [Query Languages for Data](ch02.md)
  - versus document model
    
    - convergence of models, [Convergence of document and relational databases](ch02.md)
    - data locality, [Data locality for queries](ch02.md)
- relational databases
  
  - eventual consistency, [Problems with Replication Lag](ch05.md)
  - history, [Relational Model Versus Document Model](ch02.md)
  - leader-based replication, [Leaders and Followers](ch05.md)
  - logical logs, [Logical (row-based) log replication](ch05.md)
  - philosophy compared to Unix, [Unbundling Databases](ch12.md), [The meta-database of everything](ch12.md)
  - schema changes, [Schema flexibility in the document model](ch02.md), [Encoding and Evolution](ch04.md), [Different values written at different times](ch04.md)
  - statement-based replication, [Statement-based replication](ch05.md)
  - use of B-tree indexes, [B-Trees](ch03.md)
- relationships (see edges)
- reliability, [Reliability](ch01.md)-[How Important Is Reliability?](ch01.md), [The Future of Data Systems](ch12.md)
  
  - building a reliable system from unreliable components, [Cloud Computing and Supercomputing](ch08.md)
  - defined, [Thinking About Data Systems](ch01.md), [Summary](ch01.md)
  - hardware faults, [Hardware Faults](ch01.md)
  - human errors, [Human Errors](ch01.md)
  - importance of, [How Important Is Reliability?](ch01.md)
  - of messaging systems, [Messaging Systems](ch11.md)
  - software errors, [Software Errors](ch01.md)
- Remote Method Invocation (Java RMI), [The problems with remote procedure calls (RPCs)](ch04.md)
- remote procedure calls (RPCs), [The problems with remote procedure calls (RPCs)](ch04.md)-[Data encoding and evolution for RPC](ch04.md)
  
  - (see also services)
  - based on futures, [Current directions for RPC](ch04.md)
  - data encoding and evolution, [Data encoding and evolution for RPC](ch04.md)
  - issues with, [The problems with remote procedure calls (RPCs)](ch04.md)
  - using Avro, [But what is the writer’s schema?](ch04.md), [Current directions for RPC](ch04.md)
  - using Thrift, [Current directions for RPC](ch04.md)
  - versus message brokers, [Message-Passing Dataflow](ch04.md)
- repeatable reads (transaction isolation), [Repeatable read and naming confusion](ch07.md)
- replicas, [Leaders and Followers](ch05.md)
- replication, [Replication](ch05.md)-[Summary](ch05.md), [Glossary](glossary01.md)
  
  - and durability, [Durability](ch07.md)
  - chain replication, [Synchronous Versus Asynchronous Replication](ch05.md)
  - conflict resolution and, [Conflict resolution and replication](ch07.md)
  - consistency properties, [Problems with Replication Lag](ch05.md)-[Solutions for Replication Lag](ch05.md)
    
    - consistent prefix reads, [Consistent Prefix Reads](ch05.md)
    - monotonic reads, [Monotonic Reads](ch05.md)
    - reading your own writes, [Reading Your Own Writes](ch05.md)
  - in distributed filesystems, [MapReduce and Distributed Filesystems](ch10.md)
  - leaderless, [Leaderless Replication](ch05.md)-[Version vectors](ch05.md)
    
    - detecting concurrent writes, [Detecting Concurrent Writes](ch05.md)-[Version vectors](ch05.md)
    - limitations of quorum consistency, [Limitations of Quorum Consistency](ch05.md)-[Monitoring staleness](ch05.md), [Linearizability and quorums](ch09.md)
    - sloppy quorums and hinted handoff, [Sloppy Quorums and Hinted Handoff](ch05.md)
  - monitoring staleness, [Monitoring staleness](ch05.md)
  - multi-leader, [Multi-Leader Replication](ch05.md)-[Multi-Leader Replication Topologies](ch05.md)
    
    - across multiple datacenters, [Multi-datacenter operation](ch05.md), [The Cost of Linearizability](ch09.md)
    - handling write conflicts, [Handling Write Conflicts](ch05.md)-[What is a conflict?](ch05.md)
    - replication topologies, [Multi-Leader Replication Topologies](ch05.md)-[Multi-Leader Replication Topologies](ch05.md)
  - partitioning and, [Distributed Data](part02.md), [Partitioning and Replication](ch06.md)
  - reasons for using, [Distributed Data](part02.md), [Replication](ch05.md)
  - single-leader, [Leaders and Followers](ch05.md)-[Trigger-based replication](ch05.md)
    
    - failover, [Leader failure: Failover](ch05.md)
    - implementation of replication logs, [Implementation of Replication Logs](ch05.md)-[Trigger-based replication](ch05.md)
    - relation to consensus, [Single-leader replication and consensus](ch09.md)
    - setting up new followers, [Setting Up New Followers](ch05.md)
    - synchronous versus asynchronous, [Synchronous Versus Asynchronous Replication](ch05.md)-[Synchronous Versus Asynchronous Replication](ch05.md)
  - state machine replication, [Using total order broadcast](ch09.md), [Databases and Streams](ch11.md)
  - using erasure coding, [MapReduce and Distributed Filesystems](ch10.md)
  - with heterogeneous data systems, [Keeping Systems in Sync](ch11.md)
- replication logs (see logs)
- reprocessing data, [Reprocessing data for application evolution](ch12.md), [Unifying batch and stream processing](ch12.md)
  
  - (see also evolvability)
  - from log-based messaging, [Replaying old messages](ch11.md)
- request routing, [Request Routing](ch06.md)-[Parallel Query Execution](ch06.md)
  
  - approaches to, [Request Routing](ch06.md)
  - parallel query execution, [Parallel Query Execution](ch06.md)
- resilient systems, [Reliability](ch01.md)
  
  - (see also fault tolerance)
- response time
  
  - as performance metric for services, [Describing Performance](ch01.md), [Batch Processing](ch10.md)
  - guarantees on, [Response time guarantees](ch08.md)
  - latency versus, [Describing Performance](ch01.md)
  - mean and percentiles, [Describing Performance](ch01.md)
  - user experience, [Describing Performance](ch01.md)
- responsibility and accountability, [Responsibility and accountability](ch12.md)
- REST (Representational State Transfer), [Web services](ch04.md)
  
  - (see also services)
- RethinkDB (database)
  
  - document data model, [The Object-Relational Mismatch](ch02.md)
  - dynamic partitioning, [Dynamic partitioning](ch06.md)
  - join support, [Many-to-One and Many-to-Many Relationships](ch02.md), [Convergence of document and relational databases](ch02.md)
  - key-range partitioning, [Partitioning by Key Range](ch06.md)
  - leader-based replication, [Leaders and Followers](ch05.md)
  - subscribing to changes, [API support for change streams](ch11.md)
- Riak (database)
  
  - Bitcask storage engine, [Hash Indexes](ch03.md)
  - CRDTs, [Custom conflict resolution logic](ch05.md), [Merging concurrently written values](ch05.md)
  - dotted version vectors, [Version vectors](ch05.md)
  - gossip protocol, [Request Routing](ch06.md)
  - hash partitioning, [Partitioning by Hash of Key](ch06.md)-[Partitioning by Hash of Key](ch06.md), [Fixed number of partitions](ch06.md)
  - last-write-wins conflict resolution, [Last write wins (discarding concurrent writes)](ch05.md)
  - leaderless replication, [Leaderless Replication](ch05.md)
  - LevelDB storage engine, [Making an LSM-tree out of SSTables](ch03.md)
  - linearizability, lack of, [Linearizability and quorums](ch09.md)
  - multi-datacenter support, [Multi-datacenter operation](ch05.md)
  - preventing lost updates across replicas, [Conflict resolution and replication](ch07.md)
  - rebalancing, [Operations: Automatic or Manual Rebalancing](ch06.md)
  - search feature, [Partitioning Secondary Indexes by Term](ch06.md)
  - secondary indexes, [Partitioning Secondary Indexes by Document](ch06.md)
  - siblings (concurrently written values), [Merging concurrently written values](ch05.md)
  - sloppy quorums, [Sloppy Quorums and Hinted Handoff](ch05.md)
- ring buffers, [Disk space usage](ch11.md)
- Ripple (cryptocurrency), [Tools for auditable data systems](ch12.md)
- rockets, [Human Errors](ch01.md), [Are Document Databases Repeating History?](ch02.md), [Byzantine Faults](ch08.md)
- RocksDB (storage engine), [Making an LSM-tree out of SSTables](ch03.md)
  
  - leveled compaction, [Performance optimizations](ch03.md)
- rollbacks (transactions), [Transactions](ch07.md)
- rolling upgrades, [Hardware Faults](ch01.md), [Encoding and Evolution](ch04.md)
- routing (see request routing)
- row-oriented storage, [Column-Oriented Storage](ch03.md)
  
  - row-based replication, [Logical (row-based) log replication](ch05.md)
- rowhammer (memory corruption), [Trust, but Verify](ch12.md)
- RPCs (see remote procedure calls)
- Rubygems (package manager), [The move toward declarative query languages](ch10.md)
- rules (Datalog), [The Foundation: Datalog](ch02.md)

### S

- safety and liveness properties, [Safety and liveness](ch08.md)
  
  - in consensus algorithms, [Fault-Tolerant Consensus](ch09.md)
  - in transactions, [Transactions](ch07.md)
- sagas (see compensating transactions)
- Samza (stream processor), [Stream analytics](ch11.md), [Maintaining materialized views](ch11.md)
  
  - fault tolerance, [Rebuilding state after a failure](ch11.md)
  - streaming SQL support, [Complex event processing](ch11.md)
- sandboxes, [Human Errors](ch01.md)
- SAP HANA (database), [The divergence between OLTP databases and data warehouses](ch03.md)
- scalability, [Scalability](ch01.md)-[Approaches for Coping with Load](ch01.md), [The Future of Data Systems](ch12.md)
  
  - approaches for coping with load, [Approaches for Coping with Load](ch01.md)
  - defined, [Summary](ch01.md)
  - describing load, [Describing Load](ch01.md)
  - describing performance, [Describing Performance](ch01.md)
  - partitioning and, [Partitioning](ch06.md)
  - replication and, [Problems with Replication Lag](ch05.md)
  - scaling up versus scaling out, [Distributed Data](part02.md)
- scaling out, [Approaches for Coping with Load](ch01.md), [Distributed Data](part02.md)
  
  - (see also shared-nothing architecture)
- scaling up, [Approaches for Coping with Load](ch01.md), [Distributed Data](part02.md)
- scatter/gather approach, querying partitioned databases, [Partitioning Secondary Indexes by Document](ch06.md)
- SCD (slowly changing dimension), [Time-dependence of joins](ch11.md)
- schema-on-read, [Schema flexibility in the document model](ch02.md)
  
  - comparison to evolvable schema, [The Merits of Schemas](ch04.md)
  - in distributed filesystems, [Diversity of storage](ch10.md)
- schema-on-write, [Schema flexibility in the document model](ch02.md)
- schemaless databases (see schema-on-read)
- schemas, [Glossary](glossary01.md)
  
  - Avro, [Avro](ch04.md)-[Code generation and dynamically typed languages](ch04.md)
    
    - reader determining writer’s schema, [But what is the writer’s schema?](ch04.md)
    - schema evolution, [The writer’s schema and the reader’s schema](ch04.md)
  - dynamically generated, [Dynamically generated schemas](ch04.md)
  - evolution of, [Reprocessing data for application evolution](ch12.md)
    
    - affecting application code, [Encoding and Evolution](ch04.md)
    - compatibility checking, [But what is the writer’s schema?](ch04.md)
    - in databases, [Dataflow Through Databases](ch04.md)-[Archival storage](ch04.md)
    - in message-passing, [Distributed actor frameworks](ch04.md)
    - in service calls, [Data encoding and evolution for RPC](ch04.md)
  - flexibility in document model, [Schema flexibility in the document model](ch02.md)
  - for analytics, [Stars and Snowflakes: Schemas for Analytics](ch03.md)-[Stars and Snowflakes: Schemas for Analytics](ch03.md)
  - for JSON and XML, [JSON, XML, and Binary Variants](ch04.md)
  - merits of, [The Merits of Schemas](ch04.md)
  - schema migration on railways, [Reprocessing data for application evolution](ch12.md)
  - Thrift and Protocol Buffers, [Thrift and Protocol Buffers](ch04.md)-[Datatypes and schema evolution](ch04.md)
    
    - schema evolution, [Field tags and schema evolution](ch04.md)
  - traditional approach to design, fallacy in, [Deriving several views from the same event log](ch11.md)
- searches
  
  - building search indexes in batch processes, [Building search indexes](ch10.md)
  - k-nearest neighbors, [Specialization for different domains](ch10.md)
  - on streams, [Search on streams](ch11.md)
  - partitioned secondary indexes, [Partitioning and Secondary Indexes](ch06.md)
- secondaries (see leader-based replication)
- secondary indexes, [Other Indexing Structures](ch03.md), [Glossary](glossary01.md)
  
  - partitioning, [Partitioning and Secondary Indexes](ch06.md)-[Partitioning Secondary Indexes by Term](ch06.md), [Summary](ch06.md)
    
    - document-partitioned, [Partitioning Secondary Indexes by Document](ch06.md)
    - index maintenance, [Maintaining derived state](ch12.md)
    - term-partitioned, [Partitioning Secondary Indexes by Term](ch06.md)
  - problems with dual writes, [Keeping Systems in Sync](ch11.md), [Reasoning about dataflows](ch12.md)
  - updating, transaction isolation and, [The need for multi-object transactions](ch07.md)
- secondary sorts, [Sort-merge joins](ch10.md)
- sed (Unix tool), [Simple Log Analysis](ch10.md)
- self-describing files, [Code generation and dynamically typed languages](ch04.md)
- self-joins, [Summary](ch11.md)
- self-validating systems, [A culture of verification](ch12.md)
- semantic web, [The semantic web](ch02.md)
- semi-synchronous replication, [Synchronous Versus Asynchronous Replication](ch05.md)
- sequence number ordering, [Sequence Number Ordering](ch09.md)-[Timestamp ordering is not sufficient](ch09.md)
  
  - generators, [Synchronized clocks for global snapshots](ch08.md), [Noncausal sequence number generators](ch09.md)
  - insufficiency for enforcing constraints, [Timestamp ordering is not sufficient](ch09.md)
  - Lamport timestamps, [Lamport timestamps](ch09.md)
  - use of timestamps, [Timestamps for ordering events](ch08.md), [Synchronized clocks for global snapshots](ch08.md), [Noncausal sequence number generators](ch09.md)
- sequential consistency, [Implementing linearizable storage using total order broadcast](ch09.md)
- serializability, [Isolation](ch07.md), [Weak Isolation Levels](ch07.md), [Serializability](ch07.md)-[Performance of serializable snapshot isolation](ch07.md), [Glossary](glossary01.md)
  
  - linearizability versus, [What Makes a System Linearizable?](ch09.md)
  - pessimistic versus optimistic concurrency control, [Pessimistic versus optimistic concurrency control](ch07.md)
  - serial execution, [Actual Serial Execution](ch07.md)-[Summary of serial execution](ch07.md)
    
    - partitioning, [Partitioning](ch07.md)
    - using stored procedures, [Encapsulating transactions in stored procedures](ch07.md), [Using total order broadcast](ch09.md)
  - serializable snapshot isolation (SSI), [Serializable Snapshot Isolation (SSI)](ch07.md)-[Performance of serializable snapshot isolation](ch07.md)
    
    - detecting stale MVCC reads, [Detecting stale MVCC reads](ch07.md)
    - detecting writes that affect prior reads, [Detecting writes that affect prior reads](ch07.md)
    - distributed execution, [Performance of serializable snapshot isolation](ch07.md), [Limitations of distributed transactions](ch09.md)
    - performance of SSI, [Performance of serializable snapshot isolation](ch07.md)
    - preventing write skew, [Decisions based on an outdated premise](ch07.md)-[Detecting writes that affect prior reads](ch07.md)
  - two-phase locking (2PL), [Two-Phase Locking (2PL)](ch07.md)-[Index-range locks](ch07.md)
    
    - index-range locks, [Index-range locks](ch07.md)
    - performance, [Performance of two-phase locking](ch07.md)
- Serializable (Java), [Language-Specific Formats](ch04.md)
- serialization, [Formats for Encoding Data](ch04.md)
  
  - (see also encoding)
- service discovery, [Current directions for RPC](ch04.md), [Request Routing](ch06.md), [Service discovery](ch09.md)
  
  - using DNS, [Request Routing](ch06.md), [Service discovery](ch09.md)
- service level agreements (SLAs), [Describing Performance](ch01.md)
- service-oriented architecture (SOA), [Dataflow Through Services: REST and RPC](ch04.md)
  
  - (see also services)
- services, [Dataflow Through Services: REST and RPC](ch04.md)-[Data encoding and evolution for RPC](ch04.md)
  
  - microservices, [Dataflow Through Services: REST and RPC](ch04.md)
    
    - causal dependencies across services, [The limits of total ordering](ch12.md)
    - loose coupling, [Making unbundling work](ch12.md)
  - relation to batch/stream processors, [Batch Processing](ch10.md), [Stream processors and services](ch12.md)
  - remote procedure calls (RPCs), [The problems with remote procedure calls (RPCs)](ch04.md)-[Data encoding and evolution for RPC](ch04.md)
    
    - issues with, [The problems with remote procedure calls (RPCs)](ch04.md)
  - similarity to databases, [Dataflow Through Services: REST and RPC](ch04.md)
  - web services, [Web services](ch04.md), [Current directions for RPC](ch04.md)
- session windows (stream processing), [Types of windows](ch11.md)
  
  - (see also windows)
- sessionization, [GROUP BY](ch10.md)
- sharding (see partitioning)
- shared mode (locks), [Implementation of two-phase locking](ch07.md)
- shared-disk architecture, [Distributed Data](part02.md), [MapReduce and Distributed Filesystems](ch10.md)
- shared-memory architecture, [Distributed Data](part02.md)
- shared-nothing architecture, [Approaches for Coping with Load](ch01.md), [Distributed Data](part02.md)-[Distributed Data](part02.md), [Glossary](glossary01.md)
  
  - (see also replication)
  - distributed filesystems, [MapReduce and Distributed Filesystems](ch10.md)
    
    - (see also distributed filesystems)
  - partitioning, [Partitioning](ch06.md)
  - use of network, [Unreliable Networks](ch08.md)
- sharks
  
  - biting undersea cables, [Network Faults in Practice](ch08.md)
  - counting (example), [MapReduce Querying](ch02.md)-[MapReduce Querying](ch02.md)
  - finding (example), [Query Languages for Data](ch02.md)
  - website about (example), [Declarative Queries on the Web](ch02.md)
- shredding (in relational model), [Which data model leads to simpler application code?](ch02.md)
- siblings (concurrent values), [Merging concurrently written values](ch05.md), [Conflict resolution and replication](ch07.md)
  
  - (see also conflicts)
- similarity search
  
  - edit distance, [Full-text search and fuzzy indexes](ch03.md)
  - genome data, [Summary](ch02.md)
  - k-nearest neighbors, [Specialization for different domains](ch10.md)
- single-leader replication (see leader-based replication)
- single-threaded execution, [Atomic write operations](ch07.md), [Actual Serial Execution](ch07.md)
  
  - in batch processing, [Bringing related data together in the same place](ch10.md), [Dataflow engines](ch10.md), [Parallel execution](ch10.md)
  - in stream processing, [Logs compared to traditional messaging](ch11.md), [Concurrency control](ch11.md), [Uniqueness in log-based messaging](ch12.md)
- size-tiered compaction, [Performance optimizations](ch03.md)
- skew, [Glossary](glossary01.md)
  
  - clock skew, [Relying on Synchronized Clocks](ch08.md)-[Clock readings have a confidence interval](ch08.md), [Implementing Linearizable Systems](ch09.md)
  - in transaction isolation
    
    - read skew, [Snapshot Isolation and Repeatable Read](ch07.md), [Summary](ch07.md)
    - write skew, [Write Skew and Phantoms](ch07.md)-[Materializing conflicts](ch07.md), [Decisions based on an outdated premise](ch07.md)-[Detecting writes that affect prior reads](ch07.md)
      
      - (see also write skew)
  - meanings of, [Snapshot Isolation and Repeatable Read](ch07.md)
  - unbalanced workload, [Partitioning of Key-Value Data](ch06.md)
    
    - compensating for, [Skewed Workloads and Relieving Hot Spots](ch06.md)
    - due to celebrities, [Skewed Workloads and Relieving Hot Spots](ch06.md)
    - for time-series data, [Partitioning by Key Range](ch06.md)
    - in batch processing, [Handling skew](ch10.md)
- slaves (see leader-based replication)
- sliding windows (stream processing), [Types of windows](ch11.md)
  
  - (see also windows)
- sloppy quorums, [Sloppy Quorums and Hinted Handoff](ch05.md)
  
  - (see also quorums)
  - lack of linearizability, [Implementing Linearizable Systems](ch09.md)
- slowly changing dimension (data warehouses), [Time-dependence of joins](ch11.md)
- smearing (leap seconds adjustments), [Clock Synchronization and Accuracy](ch08.md)
- snapshots (databases)
  
  - causal consistency, [Ordering and Causality](ch09.md)
  - computing derived data, [Creating an index](ch12.md)
  - in change data capture, [Initial snapshot](ch11.md)
  - serializable snapshot isolation (SSI), [Serializable Snapshot Isolation (SSI)](ch07.md)-[Performance of serializable snapshot isolation](ch07.md), [What Makes a System Linearizable?](ch09.md)
  - setting up a new replica, [Setting Up New Followers](ch05.md)
  - snapshot isolation and repeatable read, [Snapshot Isolation and Repeatable Read](ch07.md)-[Repeatable read and naming confusion](ch07.md)
    
    - implementing with MVCC, [Implementing snapshot isolation](ch07.md)
    - indexes and MVCC, [Indexes and snapshot isolation](ch07.md)
    - visibility rules, [Visibility rules for observing a consistent snapshot](ch07.md)
  - synchronized clocks for global snapshots, [Synchronized clocks for global snapshots](ch08.md)
- snowflake schemas, [Stars and Snowflakes: Schemas for Analytics](ch03.md)
- SOAP, [Web services](ch04.md)
  
  - (see also services)
  - evolvability, [Data encoding and evolution for RPC](ch04.md)
- software bugs, [Software Errors](ch01.md)
  
  - maintaining integrity, [Maintaining integrity in the face of software bugs](ch12.md)
- solid state drives (SSDs)
  
  - access patterns, [Advantages of LSM-trees](ch03.md)
  - detecting corruption, [The end-to-end argument](ch12.md), [Don’t just blindly trust what they promise](ch12.md)
  - faults in, [Durability](ch07.md)
  - sequential write throughput, [Hash Indexes](ch03.md)
- Solr (search server)
  
  - building indexes in batch processes, [Building search indexes](ch10.md)
  - document-partitioned indexes, [Partitioning Secondary Indexes by Document](ch06.md)
  - request routing, [Request Routing](ch06.md)
  - usage example, [Thinking About Data Systems](ch01.md)
  - use of Lucene, [Making an LSM-tree out of SSTables](ch03.md)
- sort (Unix tool), [Simple Log Analysis](ch10.md), [Sorting versus in-memory aggregation](ch10.md), [The Unix Philosophy](ch10.md)
- sort-merge joins (MapReduce), [Sort-merge joins](ch10.md)
- Sorted String Tables (see SSTables)
- sorting
  
  - sort order in column storage, [Sort Order in Column Storage](ch03.md)
- source of truth (see systems of record)
- Spanner (database)
  
  - data locality, [Data locality for queries](ch02.md)
  - snapshot isolation using clocks, [Synchronized clocks for global snapshots](ch08.md)
  - TrueTime API, [Clock readings have a confidence interval](ch08.md)
- Spark (processing framework), [Dataflow engines](ch10.md)-[Discussion of materialization](ch10.md)
  
  - bytecode generation, [The move toward declarative query languages](ch10.md)
  - dataflow APIs, [High-Level APIs and Languages](ch10.md)
  - fault tolerance, [Fault tolerance](ch10.md)
  - for data warehouses, [The divergence between OLTP databases and data warehouses](ch03.md)
  - GraphX API (graph processing), [The Pregel processing model](ch10.md)
  - machine learning, [Specialization for different domains](ch10.md)
  - query optimizer, [The move toward declarative query languages](ch10.md)
  - Spark Streaming, [Stream analytics](ch11.md)
    
    - microbatching, [Microbatching and checkpointing](ch11.md)
  - stream processing on top of batch processing, [Batch and Stream Processing](ch12.md)
- SPARQL (query language), [The SPARQL query language](ch02.md)
- spatial algorithms, [Specialization for different domains](ch10.md)
- split brain, [Leader failure: Failover](ch05.md), [Glossary](glossary01.md)
  
  - in consensus algorithms, [Distributed Transactions and Consensus](ch09.md), [Single-leader replication and consensus](ch09.md)
  - preventing, [Consistency and Consensus](ch09.md), [Implementing Linearizable Systems](ch09.md)
  - using fencing tokens to avoid, [The leader and the lock](ch08.md)-[Fencing tokens](ch08.md)
- spreadsheets, dataflow programming capabilities, [Designing Applications Around Dataflow](ch12.md)
- SQL (Structured Query Language), [Simplicity: Managing Complexity](ch01.md), [Relational Model Versus Document Model](ch02.md), [Query Languages for Data](ch02.md)
  
  - advantages and limitations of, [Diversity of processing models](ch10.md)
  - distributed query execution, [MapReduce Querying](ch02.md)
  - graph queries in, [Graph Queries in SQL](ch02.md)
  - isolation levels standard, issues with, [Repeatable read and naming confusion](ch07.md)
  - query execution on Hadoop, [Diversity of processing models](ch10.md)
  - résumé (example), [The Object-Relational Mismatch](ch02.md)
  - SQL injection vulnerability, [Byzantine Faults](ch08.md)
  - SQL on Hadoop, [The divergence between OLTP databases and data warehouses](ch03.md)
  - statement-based replication, [Statement-based replication](ch05.md)
  - stored procedures, [Pros and cons of stored procedures](ch07.md)
- SQL Server (database)
  
  - data warehousing support, [The divergence between OLTP databases and data warehouses](ch03.md)
  - distributed transaction support, [XA transactions](ch09.md)
  - leader-based replication, [Leaders and Followers](ch05.md)
  - preventing lost updates, [Automatically detecting lost updates](ch07.md)
  - preventing write skew, [Characterizing write skew](ch07.md), [Implementation of two-phase locking](ch07.md)
  - read committed isolation, [Implementing read committed](ch07.md)
  - recursive query support, [Graph Queries in SQL](ch02.md)
  - serializable isolation, [Implementation of two-phase locking](ch07.md)
  - snapshot isolation support, [Snapshot Isolation and Repeatable Read](ch07.md)
  - T-SQL language, [Pros and cons of stored procedures](ch07.md)
  - XML support, [The Object-Relational Mismatch](ch02.md)
- SQLstream (stream analytics), [Complex event processing](ch11.md)
- SSDs (see solid state drives)
- SSTables (storage format), [SSTables and LSM-Trees](ch03.md)-[Performance optimizations](ch03.md)
  
  - advantages over hash indexes, [SSTables and LSM-Trees](ch03.md)
  - concatenated index, [Partitioning by Hash of Key](ch06.md)
  - constructing and maintaining, [Constructing and maintaining SSTables](ch03.md)
  - making LSM-Tree from, [Making an LSM-tree out of SSTables](ch03.md)
- staleness (old data), [Reading Your Own Writes](ch05.md)
  
  - cross-channel timing dependencies, [Cross-channel timing dependencies](ch09.md)
  - in leaderless databases, [Writing to the Database When a Node Is Down](ch05.md)
  - in multi-version concurrency control, [Detecting stale MVCC reads](ch07.md)
  - monitoring for, [Monitoring staleness](ch05.md)
  - of client state, [Pushing state changes to clients](ch12.md)
  - versus linearizability, [Linearizability](ch09.md)
  - versus timeliness, [Timeliness and Integrity](ch12.md)
- standbys (see leader-based replication)
- star replication topologies, [Multi-Leader Replication Topologies](ch05.md)
- star schemas, [Stars and Snowflakes: Schemas for Analytics](ch03.md)-[Stars and Snowflakes: Schemas for Analytics](ch03.md)
  
  - similarity to event sourcing, [Event Sourcing](ch11.md)
- Star Wars analogy (event time versus processing time), [Event time versus processing time](ch11.md)
- state
  
  - derived from log of immutable events, [State, Streams, and Immutability](ch11.md)
  - deriving current state from the event log, [Deriving current state from the event log](ch11.md)
  - interplay between state changes and application code, [Dataflow: Interplay between state changes and application code](ch12.md)
  - maintaining derived state, [Maintaining derived state](ch12.md)
  - maintenance by stream processor in stream-stream joins, [Stream-stream join (window join)](ch11.md)
  - observing derived state, [Observing Derived State](ch12.md)-[Multi-partition data processing](ch12.md)
  - rebuilding after stream processor failure, [Rebuilding state after a failure](ch11.md)
  - separation of application code and, [Separation of application code and state](ch12.md)
- state machine replication, [Using total order broadcast](ch09.md), [Databases and Streams](ch11.md)
- statement-based replication, [Statement-based replication](ch05.md)
- statically typed languages
  
  - analogy to schema-on-write, [Schema flexibility in the document model](ch02.md)
  - code generation and, [Code generation and dynamically typed languages](ch04.md)
- statistical and numerical algorithms, [Specialization for different domains](ch10.md)
- StatsD (metrics aggregator), [Direct messaging from producers to consumers](ch11.md)
- stdin, stdout, [A uniform interface](ch10.md), [Separation of logic and wiring](ch10.md)
- Stellar (cryptocurrency), [Tools for auditable data systems](ch12.md)
- stock market feeds, [Direct messaging from producers to consumers](ch11.md)
- STONITH (Shoot The Other Node In The Head), [Leader failure: Failover](ch05.md)
- stop-the-world (see garbage collection)
- storage
  
  - composing data storage technologies, [Composing Data Storage Technologies](ch12.md)-[What’s missing?](ch12.md)
  - diversity of, in MapReduce, [Diversity of storage](ch10.md)
- Storage Area Network (SAN), [Distributed Data](part02.md), [MapReduce and Distributed Filesystems](ch10.md)
- storage engines, [Storage and Retrieval](ch03.md)-[Summary](ch03.md)
  
  - column-oriented, [Column-Oriented Storage](ch03.md)-[Writing to Column-Oriented Storage](ch03.md)
    
    - column compression, [Column Compression](ch03.md)-[Memory bandwidth and vectorized processing](ch03.md)
    - defined, [Column-Oriented Storage](ch03.md)
    - distinction between column families and, [Column Compression](ch03.md)
    - Parquet, [Column-Oriented Storage](ch03.md), [Archival storage](ch04.md)
    - sort order in, [Sort Order in Column Storage](ch03.md)-[Several different sort orders](ch03.md)
    - writing to, [Writing to Column-Oriented Storage](ch03.md)
  - comparing requirements for transaction processing and analytics, [Transaction Processing or Analytics?](ch03.md)-[Column-Oriented Storage](ch03.md)
  - in-memory storage, [Keeping everything in memory](ch03.md)
    
    - durability, [Durability](ch07.md)
  - row-oriented, [Data Structures That Power Your Database](ch03.md)-[Keeping everything in memory](ch03.md)
    
    - B-trees, [B-Trees](ch03.md)-[B-tree optimizations](ch03.md)
    - comparing B-trees and LSM-trees, [Comparing B-Trees and LSM-Trees](ch03.md)-[Downsides of LSM-trees](ch03.md)
    - defined, [Column-Oriented Storage](ch03.md)
    - log-structured, [Hash Indexes](ch03.md)-[Performance optimizations](ch03.md)
- stored procedures, [Trigger-based replication](ch05.md), [Encapsulating transactions in stored procedures](ch07.md)-[Pros and cons of stored procedures](ch07.md), [Glossary](glossary01.md)
  
  - and total order broadcast, [Using total order broadcast](ch09.md)
  - pros and cons of, [Pros and cons of stored procedures](ch07.md)
  - similarity to stream processors, [Application code as a derivation function](ch12.md)
- Storm (stream processor), [Stream analytics](ch11.md)
  
  - distributed RPC, [Message passing and RPC](ch11.md), [Multi-partition data processing](ch12.md)
  - Trident state handling, [Idempotence](ch11.md)
- straggler events, [Knowing when you’re ready](ch11.md), [The lambda architecture](ch12.md)
- stream processing, [Processing Streams](ch11.md)-[Summary](ch11.md), [Glossary](glossary01.md)
  
  - accessing external services within job, [Stream-table join (stream enrichment)](ch11.md), [Microbatching and checkpointing](ch11.md), [Idempotence](ch11.md), [Exactly-once execution of an operation](ch12.md)
  - combining with batch processing
    
    - lambda architecture, [The lambda architecture](ch12.md)
    - unifying technologies, [Unifying batch and stream processing](ch12.md)
  - comparison to batch processing, [Processing Streams](ch11.md)
  - complex event processing (CEP), [Complex event processing](ch11.md)
  - fault tolerance, [Fault Tolerance](ch11.md)-[Rebuilding state after a failure](ch11.md)
    
    - atomic commit, [Atomic commit revisited](ch11.md)
    - idempotence, [Idempotence](ch11.md)
    - microbatching and checkpointing, [Microbatching and checkpointing](ch11.md)
    - rebuilding state after a failure, [Rebuilding state after a failure](ch11.md)
  - for data integration, [Batch and Stream Processing](ch12.md)-[Unifying batch and stream processing](ch12.md)
  - maintaining derived state, [Maintaining derived state](ch12.md)
  - maintenance of materialized views, [Maintaining materialized views](ch11.md)
  - messaging systems (see messaging systems)
  - reasoning about time, [Reasoning About Time](ch11.md)-[Types of windows](ch11.md)
    
    - event time versus processing time, [Event time versus processing time](ch11.md), [Microbatching and checkpointing](ch11.md), [Unifying batch and stream processing](ch12.md)
    - knowing when window is ready, [Knowing when you’re ready](ch11.md)
    - types of windows, [Types of windows](ch11.md)
  - relation to databases (see streams)
  - relation to services, [Stream processors and services](ch12.md)
  - search on streams, [Search on streams](ch11.md)
  - single-threaded execution, [Logs compared to traditional messaging](ch11.md), [Concurrency control](ch11.md)
  - stream analytics, [Stream analytics](ch11.md)
  - stream joins, [Stream Joins](ch11.md)-[Time-dependence of joins](ch11.md)
    
    - stream-stream join, [Stream-stream join (window join)](ch11.md)
    - stream-table join, [Stream-table join (stream enrichment)](ch11.md)
    - table-table join, [Table-table join (materialized view maintenance)](ch11.md)
    - time-dependence of, [Time-dependence of joins](ch11.md)
- streams, [Stream Processing](ch11.md)-[Replaying old messages](ch11.md)
  
  - end-to-end, pushing events to clients, [End-to-end event streams](ch12.md)
  - messaging systems (see messaging systems)
  - processing (see stream processing)
  - relation to databases, [Databases and Streams](ch11.md)-[Limitations of immutability](ch11.md)
    
    - (see also changelogs)
    - API support for change streams, [API support for change streams](ch11.md)
    - change data capture, [Change Data Capture](ch11.md)-[API support for change streams](ch11.md)
    - derivative of state by time, [State, Streams, and Immutability](ch11.md)
    - event sourcing, [Event Sourcing](ch11.md)-[Commands and events](ch11.md)
    - keeping systems in sync, [Keeping Systems in Sync](ch11.md)-[Keeping Systems in Sync](ch11.md)
    - philosophy of immutable events, [State, Streams, and Immutability](ch11.md)-[Limitations of immutability](ch11.md)
  - topics, [Transmitting Event Streams](ch11.md)
- strict serializability, [What Makes a System Linearizable?](ch09.md)
- strong consistency (see linearizability)
- strong one-copy serializability, [What Makes a System Linearizable?](ch09.md)
- subjects, predicates, and objects (in triple-stores), [Triple-Stores and SPARQL](ch02.md)
- subscribers (message streams), [Transmitting Event Streams](ch11.md)
  
  - (see also consumers)
- supercomputers, [Cloud Computing and Supercomputing](ch08.md)
- surveillance, [Surveillance](ch12.md)
  
  - (see also privacy)
- Swagger (service definition format), [Web services](ch04.md)
- swapping to disk (see virtual memory)
- synchronous networks, [Synchronous Versus Asynchronous Networks](ch08.md), [Glossary](glossary01.md)
  
  - comparison to asynchronous networks, [Synchronous Versus Asynchronous Networks](ch08.md)
  - formal model, [System Model and Reality](ch08.md)
- synchronous replication, [Synchronous Versus Asynchronous Replication](ch05.md), [Glossary](glossary01.md)
  
  - chain replication, [Synchronous Versus Asynchronous Replication](ch05.md)
  - conflict detection, [Synchronous versus asynchronous conflict detection](ch05.md)
- system models, [Knowledge, Truth, and Lies](ch08.md), [System Model and Reality](ch08.md)-[Mapping system models to the real world](ch08.md)
  
  - assumptions in, [Trust, but Verify](ch12.md)
  - correctness of algorithms, [Correctness of an algorithm](ch08.md)
  - mapping to the real world, [Mapping system models to the real world](ch08.md)
  - safety and liveness, [Safety and liveness](ch08.md)
- systems of record, [Derived Data](part03.md), [Glossary](glossary01.md)
  
  - change data capture, [Implementing change data capture](ch11.md), [Reasoning about dataflows](ch12.md)
  - treating event log as, [State, Streams, and Immutability](ch11.md)
- systems thinking, [Feedback loops](ch12.md)

### T

- t-digest (algorithm), [Describing Performance](ch01.md)
- table-table joins, [Table-table join (materialized view maintenance)](ch11.md)
- Tableau (data visualization software), [Diversity of processing models](ch10.md)
- tail (Unix tool), [Using logs for message storage](ch11.md)
- tail vertex (property graphs), [Property Graphs](ch02.md)
- Tajo (query engine), [The divergence between OLTP databases and data warehouses](ch03.md)
- Tandem NonStop SQL (database), [Partitioning](ch06.md)
- TCP (Transmission Control Protocol), [Cloud Computing and Supercomputing](ch08.md)
  
  - comparison to circuit switching, [Can we not simply make network delays predictable?](ch08.md)
  - comparison to UDP, [Network congestion and queueing](ch08.md)
  - connection failures, [Detecting Faults](ch08.md)
  - flow control, [Network congestion and queueing](ch08.md), [Messaging Systems](ch11.md)
  - packet checksums, [Weak forms of lying](ch08.md), [The end-to-end argument](ch12.md), [Trust, but Verify](ch12.md)
  - reliability and duplicate suppression, [Duplicate suppression](ch12.md)
  - retransmission timeouts, [Network congestion and queueing](ch08.md)
  - use for transaction sessions, [Single-Object and Multi-Object Operations](ch07.md)
- telemetry (see monitoring)
- Teradata (database), [The divergence between OLTP databases and data warehouses](ch03.md), [Partitioning](ch06.md)
- term-partitioned indexes, [Partitioning Secondary Indexes by Term](ch06.md), [Summary](ch06.md)
- termination (consensus), [Fault-Tolerant Consensus](ch09.md)
- Terrapin (database), [Key-value stores as batch process output](ch10.md)
- Tez (dataflow engine), [Dataflow engines](ch10.md)-[Discussion of materialization](ch10.md)
  
  - fault tolerance, [Fault tolerance](ch10.md)
  - support by higher-level tools, [High-Level APIs and Languages](ch10.md)
- thrashing (out of memory), [Process Pauses](ch08.md)
- threads (concurrency)
  
  - actor model, [Distributed actor frameworks](ch04.md), [Message passing and RPC](ch11.md)
    
    - (see also message-passing)
  - atomic operations, [Atomicity](ch07.md)
  - background threads, [Hash Indexes](ch03.md), [Downsides of LSM-trees](ch03.md)
  - execution pauses, [Can we not simply make network delays predictable?](ch08.md), [Process Pauses](ch08.md)-[Process Pauses](ch08.md)
  - memory barriers, [Linearizability and network delays](ch09.md)
  - preemption, [Process Pauses](ch08.md)
  - single (see single-threaded execution)
- three-phase commit, [Three-phase commit](ch09.md)
- Thrift (data format), [Thrift and Protocol Buffers](ch04.md)-[Datatypes and schema evolution](ch04.md)
  
  - BinaryProtocol, [Thrift and Protocol Buffers](ch04.md)
  - CompactProtocol, [Thrift and Protocol Buffers](ch04.md)
  - field tags and schema evolution, [Field tags and schema evolution](ch04.md)
- throughput, [Describing Performance](ch01.md), [Batch Processing](ch10.md)
- TIBCO, [Message brokers](ch04.md)
  
  - Enterprise Message Service, [Message brokers compared to databases](ch11.md)
  - StreamBase (stream analytics), [Complex event processing](ch11.md)
- time
  
  - concurrency and, [The “happens-before” relationship and concurrency](ch05.md)
  - cross-channel timing dependencies, [Cross-channel timing dependencies](ch09.md)
  - in distributed systems, [Unreliable Clocks](ch08.md)-[Limiting the impact of garbage collection](ch08.md)
    
    - (see also clocks)
    - clock synchronization and accuracy, [Clock Synchronization and Accuracy](ch08.md)
    - relying on synchronized clocks, [Relying on Synchronized Clocks](ch08.md)-[Synchronized clocks for global snapshots](ch08.md)
  - process pauses, [Process Pauses](ch08.md)-[Limiting the impact of garbage collection](ch08.md)
  - reasoning about, in stream processors, [Reasoning About Time](ch11.md)-[Types of windows](ch11.md)
    
    - event time versus processing time, [Event time versus processing time](ch11.md), [Microbatching and checkpointing](ch11.md), [Unifying batch and stream processing](ch12.md)
    - knowing when window is ready, [Knowing when you’re ready](ch11.md)
    - timestamp of events, [Whose clock are you using, anyway?](ch11.md)
    - types of windows, [Types of windows](ch11.md)
  - system models for distributed systems, [System Model and Reality](ch08.md)
  - time-dependence in stream joins, [Time-dependence of joins](ch11.md)
- time-of-day clocks, [Time-of-day clocks](ch08.md)
- timeliness, [Timeliness and Integrity](ch12.md)
  
  - coordination-avoiding data systems, [Coordination-avoiding data systems](ch12.md)
  - correctness of dataflow systems, [Correctness of dataflow systems](ch12.md)
- timeouts, [Unreliable Networks](ch08.md), [Glossary](glossary01.md)
  
  - dynamic configuration of, [Network congestion and queueing](ch08.md)
  - for failover, [Leader failure: Failover](ch05.md)
  - length of, [Timeouts and Unbounded Delays](ch08.md)
- timestamps, [Sequence Number Ordering](ch09.md)
  
  - assigning to events in stream processing, [Whose clock are you using, anyway?](ch11.md)
  - for read-after-write consistency, [Reading Your Own Writes](ch05.md)
  - for transaction ordering, [Synchronized clocks for global snapshots](ch08.md)
  - insufficiency for enforcing constraints, [Timestamp ordering is not sufficient](ch09.md)
  - key range partitioning by, [Partitioning by Key Range](ch06.md)
  - Lamport, [Lamport timestamps](ch09.md)
  - logical, [Ordering events to capture causality](ch12.md)
  - ordering events, [Timestamps for ordering events](ch08.md), [Noncausal sequence number generators](ch09.md)
- Titan (database), [Graph-Like Data Models](ch02.md)
- tombstones, [Hash Indexes](ch03.md), [Merging concurrently written values](ch05.md), [Log compaction](ch11.md)
- topics (messaging), [Message brokers](ch04.md), [Transmitting Event Streams](ch11.md)
- total order, [The causal order is not a total order](ch09.md), [Glossary](glossary01.md)
  
  - limits of, [The limits of total ordering](ch12.md)
  - sequence numbers or timestamps, [Sequence Number Ordering](ch09.md)
- total order broadcast, [Total Order Broadcast](ch09.md)-[Implementing total order broadcast using linearizable storage](ch09.md), [The limits of total ordering](ch12.md), [Uniqueness in log-based messaging](ch12.md)
  
  - consensus algorithms and, [Consensus algorithms and total order broadcast](ch09.md)-[Epoch numbering and quorums](ch09.md)
  - implementation in ZooKeeper and etcd, [Membership and Coordination Services](ch09.md)
  - implementing with linearizable storage, [Implementing total order broadcast using linearizable storage](ch09.md)
  - using, [Using total order broadcast](ch09.md)
  - using to implement linearizable storage, [Implementing linearizable storage using total order broadcast](ch09.md)
- tracking behavioral data, [Privacy and Tracking](ch12.md)
  
  - (see also privacy)
- transaction coordinator (see coordinator)
- transaction manager (see coordinator)
- transaction processing, [Relational Model Versus Document Model](ch02.md), [Transaction Processing or Analytics?](ch03.md)-[Stars and Snowflakes: Schemas for Analytics](ch03.md)
  
  - comparison to analytics, [Transaction Processing or Analytics?](ch03.md)
  - comparison to data warehousing, [The divergence between OLTP databases and data warehouses](ch03.md)
- transactions, [Transactions](ch07.md)-[Summary](ch07.md), [Glossary](glossary01.md)
  
  - ACID properties of, [The Meaning of ACID](ch07.md)
    
    - atomicity, [Atomicity](ch07.md)
    - consistency, [Consistency](ch07.md)
    - durability, [Durability](ch07.md)
    - isolation, [Isolation](ch07.md)
  - compensating (see compensating transactions)
  - concept of, [The Slippery Concept of a Transaction](ch07.md)
  - distributed transactions, [Distributed Transactions and Consensus](ch09.md)-[Limitations of distributed transactions](ch09.md)
    
    - avoiding, [Derived data versus distributed transactions](ch12.md), [Making unbundling work](ch12.md), [Enforcing Constraints](ch12.md)-[Coordination-avoiding data systems](ch12.md)
    - failure amplification, [Limitations of distributed transactions](ch09.md), [Maintaining derived state](ch12.md)
    - in doubt/uncertain status, [Coordinator failure](ch09.md), [Holding locks while in doubt](ch09.md)
    - two-phase commit, [Atomic Commit and Two-Phase Commit (2PC)](ch09.md)-[Three-phase commit](ch09.md)
    - use of, [Distributed Transactions in Practice](ch09.md)-[Exactly-once message processing](ch09.md)
    - XA transactions, [XA transactions](ch09.md)-[Limitations of distributed transactions](ch09.md)
  - OLTP versus analytics queries, [The Output of Batch Workflows](ch10.md)
  - purpose of, [Transactions](ch07.md)
  - serializability, [Serializability](ch07.md)-[Performance of serializable snapshot isolation](ch07.md)
    
    - actual serial execution, [Actual Serial Execution](ch07.md)-[Summary of serial execution](ch07.md)
    - pessimistic versus optimistic concurrency control, [Pessimistic versus optimistic concurrency control](ch07.md)
    - serializable snapshot isolation (SSI), [Serializable Snapshot Isolation (SSI)](ch07.md)-[Performance of serializable snapshot isolation](ch07.md)
    - two-phase locking (2PL), [Two-Phase Locking (2PL)](ch07.md)-[Index-range locks](ch07.md)
  - single-object and multi-object, [Single-Object and Multi-Object Operations](ch07.md)-[Handling errors and aborts](ch07.md)
    
    - handling errors and aborts, [Handling errors and aborts](ch07.md)
    - need for multi-object transactions, [The need for multi-object transactions](ch07.md)
    - single-object writes, [Single-object writes](ch07.md)
  - snapshot isolation (see snapshots)
  - weak isolation levels, [Weak Isolation Levels](ch07.md)-[Materializing conflicts](ch07.md)
    
    - preventing lost updates, [Preventing Lost Updates](ch07.md)-[Conflict resolution and replication](ch07.md)
    - read committed, [Read Committed](ch07.md)-[Snapshot Isolation and Repeatable Read](ch07.md)
- transitive closure (graph algorithm), [Graphs and Iterative Processing](ch10.md)
- trie (data structure), [Full-text search and fuzzy indexes](ch03.md)
- triggers (databases), [Trigger-based replication](ch05.md), [Transmitting Event Streams](ch11.md)
  
  - implementing change data capture, [Implementing change data capture](ch11.md)
  - implementing replication, [Trigger-based replication](ch05.md)
- triple-stores, [Triple-Stores and SPARQL](ch02.md)-[The SPARQL query language](ch02.md)
  
  - SPARQL query language, [The SPARQL query language](ch02.md)
- tumbling windows (stream processing), [Types of windows](ch11.md)
  
  - (see also windows)
  - in microbatching, [Microbatching and checkpointing](ch11.md)
- tuple spaces (programming model), [Dataflow: Interplay between state changes and application code](ch12.md)
- Turtle (RDF data format), [Triple-Stores and SPARQL](ch02.md)
- Twitter
  
  - constructing home timelines (example), [Describing Load](ch01.md), [Deriving several views from the same event log](ch11.md), [Table-table join (materialized view maintenance)](ch11.md), [Materialized views and caching](ch12.md)
  - DistributedLog (event log), [Using logs for message storage](ch11.md)
  - Finagle (RPC framework), [Current directions for RPC](ch04.md)
  - Snowflake (sequence number generator), [Synchronized clocks for global snapshots](ch08.md)
  - Summingbird (processing library), [The lambda architecture](ch12.md)
- two-phase commit (2PC), [Distributed Transactions and Consensus](ch09.md), [Introduction to two-phase commit](ch09.md)-[Coordinator failure](ch09.md), [Glossary](glossary01.md)
  
  - confusion with two-phase locking, [Introduction to two-phase commit](ch09.md)
  - coordinator failure, [Coordinator failure](ch09.md)
  - coordinator recovery, [Recovering from coordinator failure](ch09.md)
  - how it works, [A system of promises](ch09.md)
  - issues in practice, [Limitations of distributed transactions](ch09.md)
  - performance cost, [Distributed Transactions in Practice](ch09.md)
  - transactions holding locks, [Holding locks while in doubt](ch09.md)
- two-phase locking (2PL), [Two-Phase Locking (2PL)](ch07.md)-[Index-range locks](ch07.md), [What Makes a System Linearizable?](ch09.md), [Glossary](glossary01.md)
  
  - confusion with two-phase commit, [Introduction to two-phase commit](ch09.md)
  - index-range locks, [Index-range locks](ch07.md)
  - performance of, [Performance of two-phase locking](ch07.md)
- type checking, dynamic versus static, [Schema flexibility in the document model](ch02.md)

### U

- UDP (User Datagram Protocol)
  
  - comparison to TCP, [Network congestion and queueing](ch08.md)
  - multicast, [Direct messaging from producers to consumers](ch11.md)
- unbounded datasets, [Stream Processing](ch11.md), [Glossary](glossary01.md)
  
  - (see also streams)
- unbounded delays, [Glossary](glossary01.md)
  
  - in networks, [Timeouts and Unbounded Delays](ch08.md)
  - process pauses, [Process Pauses](ch08.md)
- unbundling databases, [Unbundling Databases](ch12.md)-[Multi-partition data processing](ch12.md)
  
  - composing data storage technologies, [Composing Data Storage Technologies](ch12.md)-[What’s missing?](ch12.md)
    
    - federation versus unbundling, [The meta-database of everything](ch12.md)
    - need for high-level language, [What’s missing?](ch12.md)
  - designing applications around dataflow, [Designing Applications Around Dataflow](ch12.md)-[Stream processors and services](ch12.md)
  - observing derived state, [Observing Derived State](ch12.md)-[Multi-partition data processing](ch12.md)
    
    - materialized views and caching, [Materialized views and caching](ch12.md)
    - multi-partition data processing, [Multi-partition data processing](ch12.md)
    - pushing state changes to clients, [Pushing state changes to clients](ch12.md)
- uncertain (transaction status) (see in doubt)
- uniform consensus, [Fault-Tolerant Consensus](ch09.md)
  
  - (see also consensus)
- uniform interfaces, [A uniform interface](ch10.md)
- union type (in Avro), [Schema evolution rules](ch04.md)
- uniq (Unix tool), [Simple Log Analysis](ch10.md)
- uniqueness constraints
  
  - asynchronously checked, [Loosely interpreted constraints](ch12.md)
  - requiring consensus, [Uniqueness constraints require consensus](ch12.md)
  - requiring linearizability, [Constraints and uniqueness guarantees](ch09.md)
  - uniqueness in log-based messaging, [Uniqueness in log-based messaging](ch12.md)
- Unix philosophy, [The Unix Philosophy](ch10.md)-[Transparency and experimentation](ch10.md)
  
  - command-line batch processing, [Batch Processing with Unix Tools](ch10.md)-[Sorting versus in-memory aggregation](ch10.md)
    
    - Unix pipes versus dataflow engines, [Discussion of materialization](ch10.md)
  - comparison to Hadoop, [Philosophy of batch process outputs](ch10.md)-[Philosophy of batch process outputs](ch10.md)
  - comparison to relational databases, [Unbundling Databases](ch12.md), [The meta-database of everything](ch12.md)
  - comparison to stream processing, [Processing Streams](ch11.md)
  - composability and uniform interfaces, [The Unix Philosophy](ch10.md)
  - loose coupling, [Separation of logic and wiring](ch10.md)
  - pipes, [The Unix Philosophy](ch10.md)
  - relation to Hadoop, [Unbundling Databases](ch12.md)
- UPDATE statement (SQL), [Schema flexibility in the document model](ch02.md)
- updates
  
  - preventing lost updates, [Preventing Lost Updates](ch07.md)-[Conflict resolution and replication](ch07.md)
    
    - atomic write operations, [Atomic write operations](ch07.md)
    - automatically detecting lost updates, [Automatically detecting lost updates](ch07.md)
    - compare-and-set operations, [Compare-and-set](ch07.md)
    - conflict resolution and replication, [Conflict resolution and replication](ch07.md)
    - using explicit locking, [Explicit locking](ch07.md)
  - preventing write skew, [Write Skew and Phantoms](ch07.md)-[Materializing conflicts](ch07.md)

### V

- validity (consensus), [Fault-Tolerant Consensus](ch09.md)
- vBuckets (partitioning), [Partitioning](ch06.md)
- vector clocks, [Version vectors](ch05.md)
  
  - (see also version vectors)
- vectorized processing, [Memory bandwidth and vectorized processing](ch03.md), [The move toward declarative query languages](ch10.md)
- verification, [Trust, but Verify](ch12.md)-[Tools for auditable data systems](ch12.md)
  
  - avoiding blind trust, [Don’t just blindly trust what they promise](ch12.md)
  - culture of, [A culture of verification](ch12.md)
  - designing for auditability, [Designing for auditability](ch12.md)
  - end-to-end integrity checks, [The end-to-end argument again](ch12.md)
  - tools for auditable data systems, [Tools for auditable data systems](ch12.md)
- version control systems, reliance on immutable data, [Limitations of immutability](ch11.md)
- version vectors, [Multi-Leader Replication Topologies](ch05.md), [Version vectors](ch05.md)
  
  - capturing causal dependencies, [Capturing causal dependencies](ch09.md)
  - versus vector clocks, [Version vectors](ch05.md)
- Vertica (database), [The divergence between OLTP databases and data warehouses](ch03.md)
  
  - handling writes, [Writing to Column-Oriented Storage](ch03.md)
  - replicas using different sort orders, [Several different sort orders](ch03.md)
- vertical scaling (see scaling up)
- vertices (in graphs), [Graph-Like Data Models](ch02.md)
  
  - property graph model, [Property Graphs](ch02.md)
- Viewstamped Replication (consensus algorithm), [Consensus algorithms and total order broadcast](ch09.md)
  
  - view number, [Epoch numbering and quorums](ch09.md)
- virtual machines, [Distributed Data](part02.md)
  
  - (see also cloud computing)
  - context switches, [Process Pauses](ch08.md)
  - network performance, [Network congestion and queueing](ch08.md)
  - noisy neighbors, [Network congestion and queueing](ch08.md)
  - reliability in cloud services, [Hardware Faults](ch01.md)
  - virtualized clocks in, [Clock Synchronization and Accuracy](ch08.md)
- virtual memory
  
  - process pauses due to page faults, [Describing Performance](ch01.md), [Process Pauses](ch08.md)
  - versus memory management by databases, [Keeping everything in memory](ch03.md)
- VisiCalc (spreadsheets), [Designing Applications Around Dataflow](ch12.md)
- vnodes (partitioning), [Partitioning](ch06.md)
- Voice over IP (VoIP), [Network congestion and queueing](ch08.md)
- Voldemort (database)
  
  - building read-only stores in batch processes, [Key-value stores as batch process output](ch10.md)
  - hash partitioning, [Partitioning by Hash of Key](ch06.md)-[Partitioning by Hash of Key](ch06.md), [Fixed number of partitions](ch06.md)
  - leaderless replication, [Leaderless Replication](ch05.md)
  - multi-datacenter support, [Multi-datacenter operation](ch05.md)
  - rebalancing, [Operations: Automatic or Manual Rebalancing](ch06.md)
  - reliance on read repair, [Read repair and anti-entropy](ch05.md)
  - sloppy quorums, [Sloppy Quorums and Hinted Handoff](ch05.md)
- VoltDB (database)
  
  - cross-partition serializability, [Partitioning](ch07.md)
  - deterministic stored procedures, [Pros and cons of stored procedures](ch07.md)
  - in-memory storage, [Keeping everything in memory](ch03.md)
  - output streams, [API support for change streams](ch11.md)
  - secondary indexes, [Partitioning Secondary Indexes by Document](ch06.md)
  - serial execution of transactions, [Actual Serial Execution](ch07.md)
  - statement-based replication, [Statement-based replication](ch05.md), [Rebuilding state after a failure](ch11.md)
  - transactions in stream processing, [Atomic commit revisited](ch11.md)

### W

- WAL (write-ahead log), [Making B-trees reliable](ch03.md)
- web services (see services)
- Web Services Description Language (WSDL), [Web services](ch04.md)
- webhooks, [Direct messaging from producers to consumers](ch11.md)
- webMethods (messaging), [Message brokers](ch04.md)
- WebSocket (protocol), [Pushing state changes to clients](ch12.md)
- windows (stream processing), [Stream analytics](ch11.md), [Reasoning About Time](ch11.md)-[Types of windows](ch11.md)
  
  - infinite windows for changelogs, [Maintaining materialized views](ch11.md), [Stream-table join (stream enrichment)](ch11.md)
  - knowing when all events have arrived, [Knowing when you’re ready](ch11.md)
  - stream joins within a window, [Stream-stream join (window join)](ch11.md)
  - types of windows, [Types of windows](ch11.md)
- winners (conflict resolution), [Converging toward a consistent state](ch05.md)
- WITH RECURSIVE syntax (SQL), [Graph Queries in SQL](ch02.md)
- workflows (MapReduce), [MapReduce workflows](ch10.md)
  
  - outputs, [The Output of Batch Workflows](ch10.md)-[Philosophy of batch process outputs](ch10.md)
    
    - key-value stores, [Key-value stores as batch process output](ch10.md)
    - search indexes, [Building search indexes](ch10.md)
  - with map-side joins, [MapReduce workflows with map-side joins](ch10.md)
- working set, [Sorting versus in-memory aggregation](ch10.md)
- write amplification, [Advantages of LSM-trees](ch03.md)
- write path (derived data), [Observing Derived State](ch12.md)
- write skew (transaction isolation), [Write Skew and Phantoms](ch07.md)-[Materializing conflicts](ch07.md)
  
  - characterizing, [Write Skew and Phantoms](ch07.md)-[Phantoms causing write skew](ch07.md), [Decisions based on an outdated premise](ch07.md)
  - examples of, [Write Skew and Phantoms](ch07.md), [More examples of write skew](ch07.md)
  - materializing conflicts, [Materializing conflicts](ch07.md)
  - occurrence in practice, [Maintaining integrity in the face of software bugs](ch12.md)
  - phantoms, [Phantoms causing write skew](ch07.md)
  - preventing
    
    - in snapshot isolation, [Decisions based on an outdated premise](ch07.md)-[Detecting writes that affect prior reads](ch07.md)
    - in two-phase locking, [Predicate locks](ch07.md)-[Index-range locks](ch07.md)
    - options for, [Characterizing write skew](ch07.md)
- write-ahead log (WAL), [Making B-trees reliable](ch03.md), [Write-ahead log (WAL) shipping](ch05.md)
- writes (database)
  
  - atomic write operations, [Atomic write operations](ch07.md)
  - detecting writes affecting prior reads, [Detecting writes that affect prior reads](ch07.md)
  - preventing dirty writes with read committed, [No dirty writes](ch07.md)
- WS-* framework, [Web services](ch04.md)
  
  - (see also services)
- WS-AtomicTransaction (2PC), [Introduction to two-phase commit](ch09.md)

### X

- XA transactions, [Introduction to two-phase commit](ch09.md), [XA transactions](ch09.md)-[Limitations of distributed transactions](ch09.md)
  
  - heuristic decisions, [Recovering from coordinator failure](ch09.md)
  - limitations of, [Limitations of distributed transactions](ch09.md)
- xargs (Unix tool), [Simple Log Analysis](ch10.md), [A uniform interface](ch10.md)
- XML
  
  - binary variants, [Binary encoding](ch04.md)
  - encoding RDF data, [The RDF data model](ch02.md)
  - for application data, issues with, [JSON, XML, and Binary Variants](ch04.md)
  - in relational databases, [The Object-Relational Mismatch](ch02.md), [Convergence of document and relational databases](ch02.md)
- XSL/XPath, [Declarative Queries on the Web](ch02.md)

### Y

- Yahoo!
  
  - Pistachio (database), [Deriving several views from the same event log](ch11.md)
  - Sherpa (database), [Implementing change data capture](ch11.md)
- YARN (job scheduler), [Diversity of processing models](ch10.md), [Separation of application code and state](ch12.md)
  
  - preemption of jobs, [Designing for frequent faults](ch10.md)
  - use of ZooKeeper, [Membership and Coordination Services](ch09.md)

### Z

- Zab (consensus algorithm), [Consensus algorithms and total order broadcast](ch09.md)
  
  - use in ZooKeeper, [Distributed Transactions and Consensus](ch09.md)
- ZeroMQ (messaging library), [Direct messaging from producers to consumers](ch11.md)
- ZooKeeper (coordination service), [Membership and Coordination Services](ch09.md)-[Membership services](ch09.md)
  
  - generating fencing tokens, [Fencing tokens](ch08.md), [Using total order broadcast](ch09.md), [Membership and Coordination Services](ch09.md)
  - linearizable operations, [Implementing Linearizable Systems](ch09.md), [Implementing linearizable storage using total order broadcast](ch09.md)
  - locks and leader election, [Locking and leader election](ch09.md)
  - service discovery, [Service discovery](ch09.md)
  - use for partition assignment, [Request Routing](ch06.md), [Allocating work to nodes](ch09.md)
  - use of Zab algorithm, [Using total order broadcast](ch09.md), [Distributed Transactions and Consensus](ch09.md), [Consensus algorithms and total order broadcast](ch09.md)
