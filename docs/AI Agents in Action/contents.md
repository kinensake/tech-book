---
sidebar_position: 4
---

# contents

[***preface***](preface.md)

[***acknowledgments***](acknowledgments.md)

[***about this book***](about-this-book.md)

[***about the author***](about-the-author.md)

[***about the cover illustration***](about-the-cover-illustration.md)

[***1 Introduction to agents and their world***](chapter-1.md)

[1.1 Defining agents](chapter-1.md)

[1.2 Understanding the component systems of an agent](chapter-1.md)

[1.3 Examining the rise of the agent era: Why agents?](chapter-1.md)

[1.4 Peeling back the AI interface](chapter-1.md)

[1.5 Navigating the agent landscape](chapter-1.md)

[***2 Harnessing the power of large language models***](chapter-2.md)

[2.1 Mastering the OpenAI API](chapter-2.md)

[2.1.1 Connecting to the chat completions model](chapter-2.md)

[2.1.2 Understanding the request and response](chapter-2.md)

[2.2 Exploring open source LLMs with LM Studio](chapter-2.md)

[2.2.1 Installing and running LM Studio](chapter-2.md)

[2.2.2 Serving an LLM locally with LM Studio](chapter-2.md)

[2.3 Prompting LLMs with prompt engineering](chapter-2.md)

[2.3.1 Creating detailed queries](chapter-2.md)

[2.3.2 Adopting personas](chapter-2.md)

[2.3.3 Using delimiters](chapter-2.md)

[2.3.4 Specifying steps](chapter-2.md)

[2.3.5 Providing examples](chapter-2.md)

[2.3.6 Specifying output length](chapter-2.md)

[2.4 Choosing the optimal LLM for your specific needs](chapter-2.md)

[2.5 Exercises](chapter-2.md)

[***3 Engaging GPT assistants***](chapter-3.md)

[3.1 Exploring GPT assistants through ChatGPT](chapter-3.md)

[3.2 Building a GPT that can do data science](chapter-3.md)

[3.3 Customizing a GPT and adding custom actions](chapter-3.md)

[3.3.1 Creating an assistant to build an assistant](chapter-3.md)

[3.3.2 Connecting the custom action to an assistant](chapter-3.md)

[3.4 Extending an assistantâ€™s knowledge using file uploads](chapter-3.md)

[3.4.1 Building the Calculus Made Easy GPT](chapter-3.md)

[3.4.2 Knowledge search and more with file uploads](chapter-3.md)

[3.5 Publishing your GPT](chapter-3.md)

[3.5.1 Expensive GPT assistants](chapter-3.md)

[3.5.2 Understanding the economics of GPTs](chapter-3.md)

[3.5.3 Releasing the GPT](chapter-3.md)

[3.6 Exercises](chapter-3.md)

[***4 Exploring multi-agent systems***](chapter-4.md)

[4.1 Introducing multi-agent systems with AutoGen Studio](chapter-4.md)

[4.1.1 Installing and using AutoGen Studio](chapter-4.md)

[4.1.2 Adding skills in AutoGen Studio](chapter-4.md)

[4.2 Exploring AutoGen](chapter-4.md)

[4.2.1 Installing and consuming AutoGen](chapter-4.md)

[4.2.2 Enhancing code output with agent critics](chapter-4.md)

[4.2.3 Understanding the AutoGen cache](chapter-4.md)

[4.3 Group chat with agents and AutoGen](chapter-4.md)

[4.4 Building an agent crew with CrewAI](chapter-4.md)

[4.4.1 Creating a jokester crew of CrewAI agents](chapter-4.md)

[4.4.2 Observing agents working with AgentOps](chapter-4.md)

[4.5 Revisiting coding agents with CrewAI](chapter-4.md)

[4.6 Exercises](chapter-4.md)

[***5 Empowering agents with actions***](chapter-5.md)

[5.1 Defining agent actions](chapter-5.md)

[5.2 Executing OpenAI functions](chapter-5.md)

[5.2.1 Adding functions to LLM API calls](chapter-5.md)

[5.2.2 Actioning function calls](chapter-5.md)

[5.3 Introducing Semantic Kernel](chapter-5.md)

[5.3.1 Getting started with SK semantic functions](chapter-5.md)

[5.3.2 Semantic functions and context variables](chapter-5.md)

[5.4 Synergizing semantic and native functions](chapter-5.md)

[5.4.1 Creating and registering a semantic skill/plugin](chapter-5.md)

[5.4.2 Applying native functions](chapter-5.md)

[5.4.3 Embedding native functions within semantic functions](chapter-5.md)

[5.5 Semantic Kernel as an interactive service agent](chapter-5.md)

[5.5.1 Building a semantic GPT interface](chapter-5.md)

[5.5.2 Testing semantic services](chapter-5.md)

[5.5.3 Interactive chat with the semantic service layer](chapter-5.md)

[5.6 Thinking semantically when writing semantic services](chapter-5.md)

[5.7 Exercises](chapter-5.md)

[***6 Building autonomous assistants***](chapter-6.md)

[6.1 Introducing behavior trees](chapter-6.md)

[6.1.1 Understanding behavior tree execution](chapter-6.md)

[6.1.2 Deciding on behavior trees](chapter-6.md)

[6.1.3 Running behavior trees with Python and py\_trees](chapter-6.md)

[6.2 Exploring the GPT Assistants Playground](chapter-6.md)

[6.2.1 Installing and running the Playground](chapter-6.md)

[6.2.2 Using and building custom actions](chapter-6.md)

[6.2.3 Installing the assistants database](chapter-6.md)

[6.2.4 Getting an assistant to run code locally](chapter-6.md)

[6.2.5 Investigating the assistant process through logs](chapter-6.md)

[6.3 Introducing agentic behavior trees](chapter-6.md)

[6.3.1 Managing assistants with assistants](chapter-6.md)

[6.3.2 Building a coding challenge ABT](chapter-6.md)

[6.3.3 Conversational AI systems vs. other methods](chapter-6.md)

[6.3.4 Posting YouTube videos to X](chapter-6.md)

[6.3.5 Required X setup](chapter-6.md)

[6.4 Building conversational autonomous multi-agents](chapter-6.md)

[6.5 Building ABTs with back chaining](chapter-6.md)

[6.6 Exercises](chapter-6.md)

[***7 Assembling and using an agent platform***](chapter-7.md)

[7.1 Introducing Nexus, not just another agent platform](chapter-7.md)

[7.1.1 Running Nexus](chapter-7.md)

[7.1.2 Developing Nexus](chapter-7.md)

[7.2 Introducing Streamlit for chat application development](chapter-7.md)

[7.2.1 Building a Streamlit chat application](chapter-7.md)

[7.2.2 Creating a streaming chat application](chapter-7.md)

[7.3 Developing profiles and personas for agents](chapter-7.md)

[7.4 Powering the agent and understanding the agent engine](chapter-7.md)

[7.5 Giving an agent actions and tools](chapter-7.md)

[7.6 Exercises](chapter-7.md)

[***8 Understanding agent memory and knowledge***](chapter-8.md)

[8.1 Understanding retrieval in AI applications](chapter-8.md)

[8.2 The basics of retrieval augmented generation (RAG)](chapter-8.md)

[8.3 Delving into semantic search and document indexing](chapter-8.md)

[8.3.1 Applying vector similarity search](chapter-8.md)

[8.3.2 Vector databases and similarity search](chapter-8.md)

[8.3.3 Demystifying document embeddings](chapter-8.md)

[8.3.4 Querying document embeddings from Chroma](chapter-8.md)

[8.4 Constructing RAG with LangChain](chapter-8.md)

[8.4.1 Splitting and loading documents with LangChain](chapter-8.md)

[8.4.2 Splitting documents by token with LangChain](chapter-8.md)

[8.5 Applying RAG to building agent knowledge](chapter-8.md)

[8.6 Implementing memory in agentic systems](chapter-8.md)

[8.6.1 Consuming memory stores in Nexus](chapter-8.md)

[8.6.2 Semantic memory and applications to semantic, episodic, and procedural memory](chapter-8.md)

[8.7 Understanding memory and knowledge compression](chapter-8.md)

[8.8 Exercises](chapter-8.md)

[***9 Mastering agent prompts with prompt flow***](chapter-9.md)

[9.1 Why we need systematic prompt engineering](chapter-9.md)

[9.2 Understanding agent profiles and personas](chapter-9.md)

[9.3 Setting up your first prompt flow](chapter-9.md)

[9.3.1 Getting started](chapter-9.md)

[9.3.2 Creating profiles with Jinja2 templates](chapter-9.md)

[9.3.3 Deploying a prompt flow API](chapter-9.md)

[9.4 Evaluating profiles: Rubrics and grounding](chapter-9.md)

[9.5 Understanding rubrics and grounding](chapter-9.md)

[9.6 Grounding evaluation with an LLM profile](chapter-9.md)

[9.7 Comparing profiles: Getting the perfect profile](chapter-9.md)

[9.7.1 Parsing the LLM evaluation output](chapter-9.md)

[9.7.2 Running batch processing in prompt flow](chapter-9.md)

[9.7.3 Creating an evaluation flow for grounding](chapter-9.md)

[9.7.4 Exercises](chapter-9.md)

[***10 Agent reasoning and evaluation***](chapter-10.md)

[10.1 Understanding direct solution prompting](chapter-10.md)

[10.1.1 Question-and-answer prompting](chapter-10.md)

[10.1.2 Implementing few-shot prompting](chapter-10.md)

[10.1.3 Extracting generalities with zero-shot prompting](chapter-10.md)

[10.2 Reasoning in prompt engineering](chapter-10.md)

[10.2.1 Chain of thought prompting](chapter-10.md)

[10.2.2 Zero-shot CoT prompting](chapter-10.md)

[10.2.3 Step by step with prompt chaining](chapter-10.md)

[10.3 Employing evaluation for consistent solutions](chapter-10.md)

[10.3.1 Evaluating self-consistency prompting](chapter-10.md)

[10.3.2 Evaluating tree of thought prompting](chapter-10.md)

[10.4 Exercises](chapter-10.md)

[***11 Agent planning and feedback***](chapter-11.md)

[11.1 Planning: The essential tool for all agents/assistants](chapter-11.md)

[11.2 Understanding the sequential planning process](chapter-11.md)

[11.3 Building a sequential planner](chapter-11.md)

[11.4 Reviewing a stepwise planner: OpenAI Strawberry](chapter-11.md)

[11.5 Applying planning, reasoning, evaluation, and feedback to assistant and agentic systems](chapter-11.md)

[11.5.1 Application of assistant/agentic planning](chapter-11.md)

[11.5.2 Application of assistant/agentic reasoning](chapter-11.md)

[11.5.3 Application of evaluation to agentic systems](chapter-11.md)

[11.5.4 Application of feedback to agentic/assistant applications](chapter-11.md)

[11.6 Exercises](chapter-11.md)

[***appendix A Accessing OpenAI large language models***](appendix-a.md)

[A.1 Accessing OpenAI accounts and keys](appendix-a.md)

[A.2 Azure OpenAI Studio, keys, and deployments](appendix-a.md)

[***appendix B Python development environment***](appendix-b.md)

[B.1 Downloading the source code](appendix-b.md)

[B.2 Installing Python](appendix-b.md)

[B.3 Installing VS Code](appendix-b.md)

[B.4 Installing VS Code Python extensions](appendix-b.md)

[B.5 Creating a new Python environment with VS Code](appendix-b.md)

[B.6 Using VS Code Dev Containers (Docker)](appendix-b.md)

[index](index.md)
